//
//  UIGroover.swift
//  Groover
//
//  Created by Alex on 11/14/16.
//  Copyright Â© 2016 TCM. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class UIGroover : NSObject {

    //// Cache

    private struct Cache {
        static let black: UIColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        static let lightBlue: UIColor = UIColor(red: 0.349, green: 0.733, blue: 0.961, alpha: 1.000)
        static let noteGray: UIColor = UIColor(red: 0.345, green: 0.392, blue: 0.439, alpha: 1.000)
        static let noteDark: UIColor = UIColor(red: 0.173, green: 0.220, blue: 0.263, alpha: 1.000)
        static let soundParamtersBG: UIColor = UIColor(red: 0.094, green: 0.114, blue: 0.133, alpha: 1.000)
        static let buttonsBGLight: UIColor = UIColor(red: 0.173, green: 0.220, blue: 0.263, alpha: 1.000)
        static let transportDark: UIColor = UIColor(red: 0.043, green: 0.082, blue: 0.157, alpha: 1.000)
        static let transportGreen: UIColor = UIColor(red: 0.078, green: 0.576, blue: 0.059, alpha: 1.000)
        static let transportRed: UIColor = UIColor(red: 0.616, green: 0.141, blue: 0.157, alpha: 1.000)
        static let menuGray: UIColor = UIColor(red: 0.800, green: 0.847, blue: 0.890, alpha: 1.000)
        static let strokeColor: UIColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        static let clickGray: UIColor = UIColor(red: 0.400, green: 0.435, blue: 0.471, alpha: 1.000)
        static let clickDarkGray: UIColor = UIColor(red: 0.329, green: 0.345, blue: 0.361, alpha: 1.000)
        static let popupElements: UIColor = UIColor(red: 0.800, green: 0.847, blue: 0.890, alpha: 0.698)
        static let white: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        static let knobGradientColor1: UIColor = UIColor(red: 0.113, green: 0.155, blue: 0.229, alpha: 1.000)
        static let knobGradientColor2: UIColor = UIColor(red: 0.251, green: 0.306, blue: 0.364, alpha: 1.000)
        static let knobGradientColor3: UIColor = UIColor(red: 0.104, green: 0.140, blue: 0.202, alpha: 1.000)
        static let measureDark: UIColor = UIColor(red: 0.137, green: 0.431, blue: 0.604, alpha: 1.000)
        static let transparent: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        static let popupContentLight: UIColor = UIColor(red: 0.345, green: 0.392, blue: 0.439, alpha: 1.000)
        static let popupContentDark: UIColor = UIColor(red: 0.173, green: 0.220, blue: 0.263, alpha: 1.000)
        static var fullBackground: UIImage?
        static var knobBG: UIImage?
        static var rotationBG: UIImage?
        static var hamburgerIconImage: UIImage?
        static var settingsIconImage: UIImage?
        static var fullBackgroundBlur: UIImage?

    }

    //// Colors

    public dynamic class var black: UIColor { return Cache.black }
    public dynamic class var lightBlue: UIColor { return Cache.lightBlue }
    public dynamic class var noteGray: UIColor { return Cache.noteGray }
    public dynamic class var noteDark: UIColor { return Cache.noteDark }
    public dynamic class var soundParamtersBG: UIColor { return Cache.soundParamtersBG }
    public dynamic class var buttonsBGLight: UIColor { return Cache.buttonsBGLight }
    public dynamic class var transportDark: UIColor { return Cache.transportDark }
    public dynamic class var transportGreen: UIColor { return Cache.transportGreen }
    public dynamic class var transportRed: UIColor { return Cache.transportRed }
    public dynamic class var menuGray: UIColor { return Cache.menuGray }
    public dynamic class var strokeColor: UIColor { return Cache.strokeColor }
    public dynamic class var clickGray: UIColor { return Cache.clickGray }
    public dynamic class var clickDarkGray: UIColor { return Cache.clickDarkGray }
    public dynamic class var popupElements: UIColor { return Cache.popupElements }
    public dynamic class var white: UIColor { return Cache.white }
    public dynamic class var knobGradientColor1: UIColor { return Cache.knobGradientColor1 }
    public dynamic class var knobGradientColor2: UIColor { return Cache.knobGradientColor2 }
    public dynamic class var knobGradientColor3: UIColor { return Cache.knobGradientColor3 }
    public dynamic class var measureDark: UIColor { return Cache.measureDark }
    public dynamic class var transparent: UIColor { return Cache.transparent }
    public dynamic class var popupContentLight: UIColor { return Cache.popupContentLight }
    public dynamic class var popupContentDark: UIColor { return Cache.popupContentDark }

    //// Images

    public dynamic class var fullBackground: UIImage {
        if Cache.fullBackground == nil {
            Cache.fullBackground = UIImage(named: "fullBackground.png")!
        }
        return Cache.fullBackground!
    }

    public dynamic class var knobBG: UIImage {
        if Cache.knobBG == nil {
            Cache.knobBG = UIImage(named: "knobBG.png")!
        }
        return Cache.knobBG!
    }

    public dynamic class var rotationBG: UIImage {
        if Cache.rotationBG == nil {
            Cache.rotationBG = UIImage(named: "rotationBG.png")!
        }
        return Cache.rotationBG!
    }

    public dynamic class var hamburgerIconImage: UIImage {
        if Cache.hamburgerIconImage == nil {
            Cache.hamburgerIconImage = UIImage(named: "hamburgerIconImage.png")!
        }
        return Cache.hamburgerIconImage!
    }

    public dynamic class var settingsIconImage: UIImage {
        if Cache.settingsIconImage == nil {
            Cache.settingsIconImage = UIImage(named: "settingsIconImage.png")!
        }
        return Cache.settingsIconImage!
    }

    public dynamic class var fullBackgroundBlur: UIImage {
        if Cache.fullBackgroundBlur == nil {
            Cache.fullBackgroundBlur = UIImage(named: "fullBackgroundBlur.png")!
        }
        return Cache.fullBackgroundBlur!
    }

    //// Drawing Methods

    public dynamic class func drawSoundParametersCanvas(soundParametersSelected: Bool = false) {

        //// soundParametersBase Drawing
        let soundParametersBasePath = UIBezierPath(ovalIn: CGRect(x: 1, y: 1, width: 40, height: 40))
        UIGroover.soundParamtersBG.setFill()
        soundParametersBasePath.fill()


        //// soundParametersOutline Drawing
        let soundParametersOutlinePath = UIBezierPath(ovalIn: CGRect(x: 3, y: 3, width: 36, height: 36))
        UIGroover.black.setStroke()
        soundParametersOutlinePath.lineWidth = 5
        soundParametersOutlinePath.stroke()


        //// soundParametersLight Drawing
        let soundParametersLightPath = UIBezierPath(ovalIn: CGRect(x: 11, y: 11, width: 20, height: 20))
        UIGroover.buttonsBGLight.setFill()
        soundParametersLightPath.fill()


        //// soundParametersBlue Drawing
        let soundParametersBluePath = UIBezierPath(roundedRect: CGRect(x: 17, y: 17, width: 8, height: 8), cornerRadius: 2)
        UIGroover.lightBlue.setFill()
        soundParametersBluePath.fill()


        if (soundParametersSelected) {
            //// soundParametersBlueOutline Drawing
            let soundParametersBlueOutlinePath = UIBezierPath(ovalIn: CGRect(x: 11, y: 11, width: 20, height: 20))
            UIGroover.lightBlue.setStroke()
            soundParametersBlueOutlinePath.lineWidth = 2
            soundParametersBlueOutlinePath.stroke()
        }
    }

    public dynamic class func drawKnobCanvas(frame: CGRect = CGRect(x: 1, y: 0, width: 280, height: 280), rotation: CGFloat = 254, clickSelected: Bool = true, clickRingActive: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Gradient Declarations
        let linearGradient1 = CGGradient(colorsSpace: nil, colors: [UIGroover.knobGradientColor1.cgColor, UIGroover.knobGradientColor2.cgColor, UIGroover.knobGradientColor3.cgColor] as CFArray, locations: [0, 0.51, 1])!

        //// Variable Declarations
        let clickColor = clickSelected ? UIGroover.lightBlue : UIGroover.clickGray


        //// Subframes
        let clickButton: CGRect = CGRect(x: frame.minX + fastFloor((frame.width - 24) * 0.49609 + 0.5), y: frame.minY + fastFloor((frame.height - 24) * 0.50000 + 0.5), width: 24, height: 24)


        //// knobBGFrame Drawing
        let knobBGFrameRect = CGRect(x: frame.minX + fastFloor(frame.width * -0.00357 + 0.5), y: frame.minY + fastFloor(frame.height * 0.00000 + 0.5), width: fastFloor(frame.width * 1.00000 + 0.5) - fastFloor(frame.width * -0.00357 + 0.5), height: fastFloor(frame.height * 1.00000 + 0.5) - fastFloor(frame.height * 0.00000 + 0.5))
        let knobBGFramePath = UIBezierPath(rect: knobBGFrameRect)
        context.saveGState()
        knobBGFramePath.addClip()
        UIGroover.knobBG.draw(in: CGRect(x: floor(knobBGFrameRect.minX + 0.5), y: floor(knobBGFrameRect.minY + 0.5), width: UIGroover.knobBG.size.width, height: UIGroover.knobBG.size.height))
        context.restoreGState()


        //// knobRotation
        context.saveGState()
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        //// Clip knob-rotation-mask
        let knobrotationmaskPath = UIBezierPath()
        knobrotationmaskPath.move(to: CGPoint(x: 0, y: 135))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 135, y: 0), controlPoint1: CGPoint(x: 74.56, y: 135), controlPoint2: CGPoint(x: 135, y: 74.56))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 0, y: -135), controlPoint1: CGPoint(x: 135, y: -74.56), controlPoint2: CGPoint(x: 74.56, y: -135))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -135, y: 0), controlPoint1: CGPoint(x: -74.56, y: -135), controlPoint2: CGPoint(x: -135, y: -74.56))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 0, y: 135), controlPoint1: CGPoint(x: -135, y: 74.56), controlPoint2: CGPoint(x: -74.56, y: 135))
        knobrotationmaskPath.addLine(to: CGPoint(x: 0, y: 135))
        knobrotationmaskPath.addLine(to: CGPoint(x: 0, y: 135))
        knobrotationmaskPath.addLine(to: CGPoint(x: 0, y: 135))
        knobrotationmaskPath.close()
        knobrotationmaskPath.move(to: CGPoint(x: -57.9, y: -120))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -71.76, y: -112.26), controlPoint1: CGPoint(x: -62.69, y: -117.69), controlPoint2: CGPoint(x: -67.31, y: -115.1))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -92.52, y: -89.22), controlPoint1: CGPoint(x: -78.21, y: -104.31), controlPoint2: CGPoint(x: -85.13, y: -96.62))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -113.11, y: -70.42), controlPoint1: CGPoint(x: -99.16, y: -82.58), controlPoint2: CGPoint(x: -106.03, y: -76.31))
        knobrotationmaskPath.addLine(to: CGPoint(x: -113.11, y: -70.42))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -118.92, y: -60.12), controlPoint1: CGPoint(x: -115.19, y: -67.08), controlPoint2: CGPoint(x: -117.13, y: -63.65))
        knobrotationmaskPath.addLine(to: CGPoint(x: -118.92, y: -60.12))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -118.52, y: -58.65), controlPoint1: CGPoint(x: -118.46, y: -59.79), controlPoint2: CGPoint(x: -118.29, y: -59.18))
        knobrotationmaskPath.addLine(to: CGPoint(x: -123.37, y: -47.75))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -124.67, y: -47.05), controlPoint1: CGPoint(x: -123.6, y: -47.23), controlPoint2: CGPoint(x: -124.14, y: -46.95))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -130, y: -29.26), controlPoint1: CGPoint(x: -126.85, y: -41.3), controlPoint2: CGPoint(x: -128.63, y: -35.36))
        knobrotationmaskPath.addLine(to: CGPoint(x: -130, y: -29.26))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -128.32, y: 2.65), controlPoint1: CGPoint(x: -128.89, y: -18.78), controlPoint2: CGPoint(x: -128.32, y: -8.13))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -129.64, y: 30.94), controlPoint1: CGPoint(x: -128.32, y: 12.19), controlPoint2: CGPoint(x: -128.76, y: 21.62))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -125.46, y: 45.03), controlPoint1: CGPoint(x: -128.5, y: 35.74), controlPoint2: CGPoint(x: -127.1, y: 40.44))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -124.18, y: 45.72), controlPoint1: CGPoint(x: -124.94, y: 44.95), controlPoint2: CGPoint(x: -124.4, y: 45.22))
        knobrotationmaskPath.addLine(to: CGPoint(x: -119.33, y: 56.63))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -119.92, y: 58.21), controlPoint1: CGPoint(x: -119.06, y: 57.23), controlPoint2: CGPoint(x: -119.32, y: 57.93))
        knobrotationmaskPath.addLine(to: CGPoint(x: -119.92, y: 58.21))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -112.01, y: 72.26), controlPoint1: CGPoint(x: -117.56, y: 63.06), controlPoint2: CGPoint(x: -114.92, y: 67.75))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -89.66, y: 92.52), controlPoint1: CGPoint(x: -104.31, y: 78.57), controlPoint2: CGPoint(x: -96.84, y: 85.32))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -71.24, y: 112.69), controlPoint1: CGPoint(x: -83.15, y: 99.02), controlPoint2: CGPoint(x: -77.02, y: 105.76))
        knobrotationmaskPath.addLine(to: CGPoint(x: -71.24, y: 112.69))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -58.76, y: 119.69), controlPoint1: CGPoint(x: -67.22, y: 115.24), controlPoint2: CGPoint(x: -63.06, y: 117.58))
        knobrotationmaskPath.addLine(to: CGPoint(x: -58.76, y: 119.69))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -57.42, y: 119.41), controlPoint1: CGPoint(x: -58.43, y: 119.34), controlPoint2: CGPoint(x: -57.89, y: 119.21))
        knobrotationmaskPath.addLine(to: CGPoint(x: -46.44, y: 124.08))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -45.72, y: 125.26), controlPoint1: CGPoint(x: -45.96, y: 124.28), controlPoint2: CGPoint(x: -45.68, y: 124.76))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -29.58, y: 130), controlPoint1: CGPoint(x: -40.48, y: 127.17), controlPoint2: CGPoint(x: -35.1, y: 128.75))
        knobrotationmaskPath.addLine(to: CGPoint(x: -29.58, y: 130))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 0.69, y: 128.48), controlPoint1: CGPoint(x: -19.63, y: 129), controlPoint2: CGPoint(x: -9.53, y: 128.48))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 29.73, y: 129.88), controlPoint1: CGPoint(x: 10.49, y: 128.48), controlPoint2: CGPoint(x: 20.17, y: 128.95))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 44.43, y: 125.58), controlPoint1: CGPoint(x: 34.74, y: 128.72), controlPoint2: CGPoint(x: 39.65, y: 127.29))
        knobrotationmaskPath.addLine(to: CGPoint(x: 44.36, y: 125.4))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 44.99, y: 123.84), controlPoint1: CGPoint(x: 44.1, y: 124.8), controlPoint2: CGPoint(x: 44.39, y: 124.09))
        knobrotationmaskPath.addLine(to: CGPoint(x: 55.97, y: 119.17))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 57.54, y: 119.8), controlPoint1: CGPoint(x: 56.58, y: 118.91), controlPoint2: CGPoint(x: 57.28, y: 119.19))
        knobrotationmaskPath.addLine(to: CGPoint(x: 57.64, y: 120.05))
        knobrotationmaskPath.addLine(to: CGPoint(x: 57.64, y: 120.05))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 70.27, y: 113.06), controlPoint1: CGPoint(x: 61.99, y: 117.95), controlPoint2: CGPoint(x: 66.21, y: 115.61))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 91.05, y: 90.02), controlPoint1: CGPoint(x: 76.73, y: 105.11), controlPoint2: CGPoint(x: 83.65, y: 97.42))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 113, y: 70.09), controlPoint1: CGPoint(x: 98.11, y: 82.95), controlPoint2: CGPoint(x: 105.44, y: 76.3))
        knobrotationmaskPath.addLine(to: CGPoint(x: 113, y: 70.09))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 119.1, y: 59.1), controlPoint1: CGPoint(x: 115.2, y: 66.54), controlPoint2: CGPoint(x: 117.23, y: 62.87))
        knobrotationmaskPath.addLine(to: CGPoint(x: 119.1, y: 59.1))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 118.56, y: 57.58), controlPoint1: CGPoint(x: 118.55, y: 58.82), controlPoint2: CGPoint(x: 118.31, y: 58.15))
        knobrotationmaskPath.addLine(to: CGPoint(x: 123.22, y: 46.59))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 124.75, y: 45.94), controlPoint1: CGPoint(x: 123.47, y: 45.99), controlPoint2: CGPoint(x: 124.15, y: 45.7))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 130, y: 27.61), controlPoint1: CGPoint(x: 126.92, y: 40.01), controlPoint2: CGPoint(x: 128.68, y: 33.9))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 128.71, y: -0.32), controlPoint1: CGPoint(x: 129.15, y: 18.42), controlPoint2: CGPoint(x: 128.71, y: 9.1))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 129.95, y: -27.73), controlPoint1: CGPoint(x: 128.71, y: -9.56), controlPoint2: CGPoint(x: 129.13, y: -18.71))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 125.08, y: -44.9), controlPoint1: CGPoint(x: 128.71, y: -33.61), controlPoint2: CGPoint(x: 127.08, y: -39.34))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 123.68, y: -45.59), controlPoint1: CGPoint(x: 124.52, y: -44.75), controlPoint2: CGPoint(x: 123.91, y: -45.04))
        knobrotationmaskPath.addLine(to: CGPoint(x: 119.02, y: -56.58))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 119.54, y: -58.1), controlPoint1: CGPoint(x: 118.78, y: -57.15), controlPoint2: CGPoint(x: 119.01, y: -57.8))
        knobrotationmaskPath.addLine(to: CGPoint(x: 119.54, y: -58.1))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 111.59, y: -72.21), controlPoint1: CGPoint(x: 117.17, y: -62.97), controlPoint2: CGPoint(x: 114.52, y: -67.68))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 90.54, y: -91.39), controlPoint1: CGPoint(x: 104.35, y: -78.2), controlPoint2: CGPoint(x: 97.33, y: -84.6))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 71.76, y: -112.01), controlPoint1: CGPoint(x: 83.9, y: -98.04), controlPoint2: CGPoint(x: 77.64, y: -104.92))
        knobrotationmaskPath.addLine(to: CGPoint(x: 71.76, y: -112.01))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 60.41, y: -118.56), controlPoint1: CGPoint(x: 68.1, y: -114.37), controlPoint2: CGPoint(x: 64.31, y: -116.56))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 59.06, y: -118.3), controlPoint1: CGPoint(x: 60.07, y: -118.21), controlPoint2: CGPoint(x: 59.53, y: -118.09))
        knobrotationmaskPath.addLine(to: CGPoint(x: 48.17, y: -123.16))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 47.46, y: -124.35), controlPoint1: CGPoint(x: 47.69, y: -123.37), controlPoint2: CGPoint(x: 47.41, y: -123.86))
        knobrotationmaskPath.addCurve(to: CGPoint(x: 28.72, y: -130), controlPoint1: CGPoint(x: 41.41, y: -126.68), controlPoint2: CGPoint(x: 35.15, y: -128.57))
        knobrotationmaskPath.addLine(to: CGPoint(x: 28.72, y: -130))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -0.26, y: -128.61), controlPoint1: CGPoint(x: 19.18, y: -129.08), controlPoint2: CGPoint(x: 9.52, y: -128.61))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -29.14, y: -129.99), controlPoint1: CGPoint(x: -10, y: -128.61), controlPoint2: CGPoint(x: -19.64, y: -129.08))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -44.69, y: -125.52), controlPoint1: CGPoint(x: -34.45, y: -128.81), controlPoint2: CGPoint(x: -39.64, y: -127.31))
        knobrotationmaskPath.addLine(to: CGPoint(x: -44.58, y: -125.26))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -45.23, y: -123.7), controlPoint1: CGPoint(x: -44.33, y: -124.65), controlPoint2: CGPoint(x: -44.62, y: -123.95))
        knobrotationmaskPath.addLine(to: CGPoint(x: -56.25, y: -119.13))
        knobrotationmaskPath.addCurve(to: CGPoint(x: -57.81, y: -119.77), controlPoint1: CGPoint(x: -56.86, y: -118.87), controlPoint2: CGPoint(x: -57.55, y: -119.16))
        knobrotationmaskPath.addLine(to: CGPoint(x: -57.9, y: -120))
        knobrotationmaskPath.addLine(to: CGPoint(x: -57.9, y: -120))
        knobrotationmaskPath.addLine(to: CGPoint(x: -57.9, y: -120))
        knobrotationmaskPath.addLine(to: CGPoint(x: -57.9, y: -120))
        knobrotationmaskPath.addLine(to: CGPoint(x: -57.9, y: -120))
        knobrotationmaskPath.close()
        knobrotationmaskPath.usesEvenOddFillRule = true
        var knobrotationmaskTransformation = CGAffineTransform.identity
        knobrotationmaskTransformation = knobrotationmaskTransformation.translatedBy(x: 140, y: 140)
        knobrotationmaskTransformation = knobrotationmaskTransformation.rotated(by: -rotation * CGFloat.pi/180)
        knobrotationmaskPath.apply(knobrotationmaskTransformation)
        knobrotationmaskPath.addClip()


        //// rotationBGFrame Drawing
        let rotationBGFramePath = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 280, height: 280))
        context.saveGState()
        rotationBGFramePath.addClip()
        UIGroover.rotationBG.draw(in: CGRect(x: 0, y: 0, width: UIGroover.rotationBG.size.width, height: UIGroover.rotationBG.size.height))
        context.restoreGState()


        context.endTransparencyLayer()
        context.restoreGState()


        //// rotationBevels
        context.saveGState()
        context.translateBy(x: frame.minX + 0.49643 * frame.width, y: frame.minY + 0.50000 * frame.height)
        context.rotate(by: -rotation * CGFloat.pi/180)



        //// bevel-8 Drawing
        let bevel8Path = UIBezierPath()
        bevel8Path.move(to: CGPoint(x: -73.06, y: -111.29))
        bevel8Path.addCurve(to: CGPoint(x: -114.39, y: -69.98), controlPoint1: CGPoint(x: -87.25, y: -94.4), controlPoint2: CGPoint(x: -94.31, y: -86.86))
        bevel8Path.addLine(to: CGPoint(x: -111.8, y: -73.66))
        bevel8Path.addCurve(to: CGPoint(x: -77.22, y: -108.29), controlPoint1: CGPoint(x: -96.51, y: -88.32), controlPoint2: CGPoint(x: -89.79, y: -94.22))
        bevel8Path.addLine(to: CGPoint(x: -73.06, y: -111.29))
        bevel8Path.close()
        context.saveGState()
        bevel8Path.addClip()
        context.drawLinearGradient(linearGradient1,
            start: CGPoint(x: -74.67, y: -111.32),
            end: CGPoint(x: -112.97, y: -73.1),
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()


        //// bevel-7 Drawing
        let bevel7Path = UIBezierPath()
        bevel7Path.move(to: CGPoint(x: -130.18, y: -29))
        bevel7Path.addCurve(to: CGPoint(x: -130.2, y: 29.44), controlPoint1: CGPoint(x: -128.27, y: -7.02), controlPoint2: CGPoint(x: -127.93, y: 3.31))
        bevel7Path.addLine(to: CGPoint(x: -130.97, y: 25))
        bevel7Path.addCurve(to: CGPoint(x: -131, y: -23.93), controlPoint1: CGPoint(x: -130.52, y: 3.82), controlPoint2: CGPoint(x: -129.95, y: -5.1))
        bevel7Path.addLine(to: CGPoint(x: -130.18, y: -29))
        bevel7Path.close()
        context.saveGState()
        bevel7Path.addClip()
        context.drawLinearGradient(linearGradient1,
            start: CGPoint(x: -131.34, y: -27.88),
            end: CGPoint(x: -131.4, y: 26.23),
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()


        //// bevel-6 Drawing
        let bevel6Path = UIBezierPath()
        bevel6Path.move(to: CGPoint(x: -111.68, y: 73))
        bevel6Path.addCurve(to: CGPoint(x: -70.37, y: 114.33), controlPoint1: CGPoint(x: -94.79, y: 87.19), controlPoint2: CGPoint(x: -87.24, y: 94.25))
        bevel6Path.addLine(to: CGPoint(x: -74.05, y: 111.75))
        bevel6Path.addCurve(to: CGPoint(x: -108.68, y: 77.16), controlPoint1: CGPoint(x: -88.71, y: 96.45), controlPoint2: CGPoint(x: -94.61, y: 89.74))
        bevel6Path.addLine(to: CGPoint(x: -111.68, y: 73))
        bevel6Path.close()
        context.saveGState()
        bevel6Path.addClip()
        context.drawLinearGradient(linearGradient1,
            start: CGPoint(x: -111.71, y: 74.61),
            end: CGPoint(x: -73.49, y: 112.91),
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()


        //// bevel-5 Drawing
        let bevel5Path = UIBezierPath()
        bevel5Path.move(to: CGPoint(x: -29.39, y: 130.19))
        bevel5Path.addCurve(to: CGPoint(x: 29.05, y: 130.21), controlPoint1: CGPoint(x: -7.41, y: 128.28), controlPoint2: CGPoint(x: 2.92, y: 127.94))
        bevel5Path.addLine(to: CGPoint(x: 24.62, y: 130.98))
        bevel5Path.addCurve(to: CGPoint(x: -24.32, y: 131.01), controlPoint1: CGPoint(x: 3.43, y: 130.53), controlPoint2: CGPoint(x: -5.49, y: 129.96))
        bevel5Path.addLine(to: CGPoint(x: -29.39, y: 130.19))
        bevel5Path.close()
        context.saveGState()
        bevel5Path.addClip()
        context.drawLinearGradient(linearGradient1,
            start: CGPoint(x: -28.27, y: 131.35),
            end: CGPoint(x: 25.84, y: 131.41),
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()


        //// bevel-4 Drawing
        let bevel4Path = UIBezierPath()
        bevel4Path.move(to: CGPoint(x: 70.11, y: 112.52))
        bevel4Path.addCurve(to: CGPoint(x: 111.44, y: 71.21), controlPoint1: CGPoint(x: 84.3, y: 95.63), controlPoint2: CGPoint(x: 91.36, y: 88.08))
        bevel4Path.addLine(to: CGPoint(x: 108.86, y: 74.89))
        bevel4Path.addCurve(to: CGPoint(x: 74.27, y: 109.51), controlPoint1: CGPoint(x: 93.56, y: 89.55), controlPoint2: CGPoint(x: 86.85, y: 95.45))
        bevel4Path.addLine(to: CGPoint(x: 70.11, y: 112.52))
        bevel4Path.close()
        context.saveGState()
        bevel4Path.addClip()
        context.drawLinearGradient(linearGradient1,
            start: CGPoint(x: 71.73, y: 112.55),
            end: CGPoint(x: 110.02, y: 74.33),
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()


        //// bevel-3 Drawing
        let bevel3Path = UIBezierPath()
        bevel3Path.move(to: CGPoint(x: 129.79, y: 29.69))
        bevel3Path.addCurve(to: CGPoint(x: 130.1, y: -29), controlPoint1: CGPoint(x: 127.98, y: 7.63), controlPoint2: CGPoint(x: 127.69, y: -2.74))
        bevel3Path.addLine(to: CGPoint(x: 130.86, y: -24.55))
        bevel3Path.addCurve(to: CGPoint(x: 130.64, y: 24.6), controlPoint1: CGPoint(x: 130.3, y: -3.27), controlPoint2: CGPoint(x: 129.67, y: 5.69))
        bevel3Path.addLine(to: CGPoint(x: 129.79, y: 29.69))
        bevel3Path.close()
        context.saveGState()
        bevel3Path.addClip()
        context.drawLinearGradient(linearGradient1,
            start: CGPoint(x: 130.96, y: 28.56),
            end: CGPoint(x: 131.29, y: -25.78),
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()


        //// bevel-2 Drawing
        let bevel2Path = UIBezierPath()
        bevel2Path.move(to: CGPoint(x: 111.7, y: -71.97))
        bevel2Path.addCurve(to: CGPoint(x: 71.34, y: -112.35), controlPoint1: CGPoint(x: 95.19, y: -85.84), controlPoint2: CGPoint(x: 87.82, y: -92.73))
        bevel2Path.addLine(to: CGPoint(x: 74.93, y: -109.82))
        bevel2Path.addCurve(to: CGPoint(x: 108.76, y: -76.04), controlPoint1: CGPoint(x: 89.26, y: -94.88), controlPoint2: CGPoint(x: 95.02, y: -88.32))
        bevel2Path.addLine(to: CGPoint(x: 111.7, y: -71.97))
        bevel2Path.close()
        context.saveGState()
        bevel2Path.addClip()
        context.drawLinearGradient(linearGradient1,
            start: CGPoint(x: 111.72, y: -73.55),
            end: CGPoint(x: 74.38, y: -110.96),
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()


        //// bevel-1 Drawing
        let bevel1Path = UIBezierPath()
        bevel1Path.move(to: CGPoint(x: 29.38, y: -129.89))
        bevel1Path.addCurve(to: CGPoint(x: -29.05, y: -129.9), controlPoint1: CGPoint(x: 7.4, y: -127.98), controlPoint2: CGPoint(x: -2.92, y: -127.64))
        bevel1Path.addLine(to: CGPoint(x: -24.62, y: -130.68))
        bevel1Path.addCurve(to: CGPoint(x: 24.31, y: -130.71), controlPoint1: CGPoint(x: -3.44, y: -130.23), controlPoint2: CGPoint(x: 5.48, y: -129.65))
        bevel1Path.addLine(to: CGPoint(x: 29.38, y: -129.89))
        bevel1Path.close()
        context.saveGState()
        bevel1Path.addClip()
        context.drawLinearGradient(linearGradient1,
            start: CGPoint(x: 28.26, y: -131.05),
            end: CGPoint(x: -25.84, y: -131.1),
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()



        context.restoreGState()


        //// clickButton
        //// clickOval7 Drawing
        context.saveGState()
        context.translateBy(x: clickButton.minX + 12, y: clickButton.minY + 21)

        let clickOval7Path = UIBezierPath(ovalIn: CGRect(x: -3, y: -3, width: 6, height: 6))
        clickColor.setFill()
        clickOval7Path.fill()
        UIGroover.clickDarkGray.setStroke()
        clickOval7Path.lineWidth = 1
        clickOval7Path.stroke()

        context.restoreGState()


        //// clickOval6 Drawing
        let clickOval6Path = UIBezierPath(ovalIn: CGRect(x: clickButton.minX, y: clickButton.minY + 18, width: 6, height: 6))
        clickColor.setFill()
        clickOval6Path.fill()
        UIGroover.clickDarkGray.setStroke()
        clickOval6Path.lineWidth = 1
        clickOval6Path.stroke()


        //// clickOval5 Drawing
        let clickOval5Path = UIBezierPath(ovalIn: CGRect(x: clickButton.minX + 18, y: clickButton.minY + 9, width: 6, height: 6))
        clickColor.setFill()
        clickOval5Path.fill()
        UIGroover.clickDarkGray.setStroke()
        clickOval5Path.lineWidth = 1
        clickOval5Path.stroke()


        //// clickOval4 Drawing
        let clickOval4Path = UIBezierPath(ovalIn: CGRect(x: clickButton.minX + 9, y: clickButton.minY + 9, width: 6, height: 6))
        clickColor.setFill()
        clickOval4Path.fill()
        UIGroover.clickDarkGray.setStroke()
        clickOval4Path.lineWidth = 1
        clickOval4Path.stroke()


        //// clickOval3 Drawing
        let clickOval3Path = UIBezierPath(ovalIn: CGRect(x: clickButton.minX, y: clickButton.minY + 9, width: 6, height: 6))
        clickColor.setFill()
        clickOval3Path.fill()
        UIGroover.clickDarkGray.setStroke()
        clickOval3Path.lineWidth = 1
        clickOval3Path.stroke()


        //// clickOval2 Drawing
        let clickOval2Path = UIBezierPath(ovalIn: CGRect(x: clickButton.minX + 18, y: clickButton.minY, width: 6, height: 6))
        clickColor.setFill()
        clickOval2Path.fill()
        UIGroover.clickDarkGray.setStroke()
        clickOval2Path.lineWidth = 1
        clickOval2Path.stroke()


        //// clickOval1 Drawing
        context.saveGState()
        context.translateBy(x: clickButton.minX + 12, y: clickButton.minY + 3)

        let clickOval1Path = UIBezierPath(ovalIn: CGRect(x: -3, y: -3, width: 6, height: 6))
        clickColor.setFill()
        clickOval1Path.fill()
        UIGroover.clickDarkGray.setStroke()
        clickOval1Path.lineWidth = 1
        clickOval1Path.stroke()

        context.restoreGState()




        if (clickRingActive) {
            //// clickRing Drawing
            let clickRingPath = UIBezierPath(ovalIn: CGRect(x: frame.minX + fastFloor(frame.width * 0.28571 + 0.5), y: frame.minY + fastFloor((frame.height - 118) * 0.50000 + 0.5), width: fastFloor(frame.width * 0.70714 + 0.5) - fastFloor(frame.width * 0.28571 + 0.5), height: 118))
            UIGroover.lightBlue.setStroke()
            clickRingPath.lineWidth = 2
            clickRingPath.stroke()
        }
    }

    public dynamic class func drawPositionsCanvas(position1Selected: Bool = false) {

        //// Variable Declarations
        let position1Color = position1Selected ? UIGroover.lightBlue : UIGroover.buttonsBGLight

        //// position1 Drawing
        let position1Path = UIBezierPath(roundedRect: CGRect(x: 0, y: 0, width: 13, height: 13), cornerRadius: 2)
        position1Color.setFill()
        position1Path.fill()
    }

    public dynamic class func drawHamburgerCanvas(hamburgerSelected: Bool = false) {

        //// Variable Declarations
        let hamburgerColor = hamburgerSelected ? UIGroover.lightBlue : UIGroover.menuGray

        //// hamburgerBottom Drawing
        let hamburgerBottomPath = UIBezierPath(roundedRect: CGRect(x: 11, y: 26, width: 22, height: 3), cornerRadius: 1)
        hamburgerColor.setFill()
        hamburgerBottomPath.fill()


        //// hamburgerMiddle Drawing
        let hamburgerMiddlePath = UIBezierPath(roundedRect: CGRect(x: 11, y: 20, width: 22, height: 3), cornerRadius: 1)
        hamburgerColor.setFill()
        hamburgerMiddlePath.fill()


        //// hamburgerTop Drawing
        let hamburgerTopPath = UIBezierPath(roundedRect: CGRect(x: 11, y: 14, width: 22, height: 3), cornerRadius: 1)
        hamburgerColor.setFill()
        hamburgerTopPath.fill()
    }

    public dynamic class func drawSettingsIconCanvas(settingsSelected: Bool = false) {

        //// Variable Declarations
        let settingsColor = settingsSelected ? UIGroover.lightBlue : UIGroover.menuGray

        //// settingsButton Drawing
        let settingsButtonPath = UIBezierPath()
        settingsButtonPath.move(to: CGPoint(x: 33, y: 23.35))
        settingsButtonPath.addLine(to: CGPoint(x: 33, y: 20.6))
        settingsButtonPath.addLine(to: CGPoint(x: 29.73, y: 20.07))
        settingsButtonPath.addCurve(to: CGPoint(x: 28.83, y: 17.9), controlPoint1: CGPoint(x: 29.53, y: 19.29), controlPoint2: CGPoint(x: 29.23, y: 18.56))
        settingsButtonPath.addLine(to: CGPoint(x: 30.74, y: 15.18))
        settingsButtonPath.addLine(to: CGPoint(x: 28.79, y: 13.24))
        settingsButtonPath.addLine(to: CGPoint(x: 26.11, y: 15.17))
        settingsButtonPath.addCurve(to: CGPoint(x: 23.92, y: 14.26), controlPoint1: CGPoint(x: 25.44, y: 14.76), controlPoint2: CGPoint(x: 24.7, y: 14.45))
        settingsButtonPath.addLine(to: CGPoint(x: 23.35, y: 11))
        settingsButtonPath.addLine(to: CGPoint(x: 20.6, y: 11))
        settingsButtonPath.addLine(to: CGPoint(x: 20.07, y: 14.25))
        settingsButtonPath.addCurve(to: CGPoint(x: 17.88, y: 15.15), controlPoint1: CGPoint(x: 19.29, y: 14.44), controlPoint2: CGPoint(x: 18.56, y: 14.74))
        settingsButtonPath.addLine(to: CGPoint(x: 15.21, y: 13.23))
        settingsButtonPath.addLine(to: CGPoint(x: 13.26, y: 15.18))
        settingsButtonPath.addLine(to: CGPoint(x: 15.15, y: 17.87))
        settingsButtonPath.addCurve(to: CGPoint(x: 14.23, y: 20.07), controlPoint1: CGPoint(x: 14.74, y: 18.54), controlPoint2: CGPoint(x: 14.43, y: 19.28))
        settingsButtonPath.addLine(to: CGPoint(x: 11, y: 20.6))
        settingsButtonPath.addLine(to: CGPoint(x: 11, y: 23.35))
        settingsButtonPath.addLine(to: CGPoint(x: 14.23, y: 23.93))
        settingsButtonPath.addCurve(to: CGPoint(x: 15.14, y: 26.12), controlPoint1: CGPoint(x: 14.42, y: 24.71), controlPoint2: CGPoint(x: 14.73, y: 25.45))
        settingsButtonPath.addLine(to: CGPoint(x: 13.23, y: 28.79))
        settingsButtonPath.addLine(to: CGPoint(x: 15.18, y: 30.73))
        settingsButtonPath.addLine(to: CGPoint(x: 17.87, y: 28.85))
        settingsButtonPath.addCurve(to: CGPoint(x: 20.06, y: 29.75), controlPoint1: CGPoint(x: 18.55, y: 29.25), controlPoint2: CGPoint(x: 19.28, y: 29.56))
        settingsButtonPath.addLine(to: CGPoint(x: 20.6, y: 33))
        settingsButtonPath.addLine(to: CGPoint(x: 23.35, y: 33))
        settingsButtonPath.addLine(to: CGPoint(x: 23.93, y: 29.74))
        settingsButtonPath.addCurve(to: CGPoint(x: 26.11, y: 28.83), controlPoint1: CGPoint(x: 24.71, y: 29.55), controlPoint2: CGPoint(x: 25.44, y: 29.24))
        settingsButtonPath.addLine(to: CGPoint(x: 28.82, y: 30.73))
        settingsButtonPath.addLine(to: CGPoint(x: 30.77, y: 28.79))
        settingsButtonPath.addLine(to: CGPoint(x: 28.83, y: 26.1))
        settingsButtonPath.addCurve(to: CGPoint(x: 29.73, y: 23.93), controlPoint1: CGPoint(x: 29.23, y: 25.43), controlPoint2: CGPoint(x: 29.54, y: 24.7))
        settingsButtonPath.addLine(to: CGPoint(x: 33, y: 23.35))
        settingsButtonPath.addLine(to: CGPoint(x: 33, y: 23.35))
        settingsButtonPath.close()
        settingsButtonPath.move(to: CGPoint(x: 22, y: 25.67))
        settingsButtonPath.addCurve(to: CGPoint(x: 18.33, y: 22), controlPoint1: CGPoint(x: 19.98, y: 25.67), controlPoint2: CGPoint(x: 18.33, y: 24.02))
        settingsButtonPath.addCurve(to: CGPoint(x: 22, y: 18.33), controlPoint1: CGPoint(x: 18.33, y: 19.98), controlPoint2: CGPoint(x: 19.98, y: 18.33))
        settingsButtonPath.addCurve(to: CGPoint(x: 25.67, y: 22), controlPoint1: CGPoint(x: 24.02, y: 18.33), controlPoint2: CGPoint(x: 25.67, y: 19.98))
        settingsButtonPath.addCurve(to: CGPoint(x: 22, y: 25.67), controlPoint1: CGPoint(x: 25.67, y: 24.02), controlPoint2: CGPoint(x: 24.02, y: 25.67))
        settingsButtonPath.addLine(to: CGPoint(x: 22, y: 25.67))
        settingsButtonPath.close()
        settingsColor.setFill()
        settingsButtonPath.fill()
    }

    public dynamic class func drawLeftCanvas() {

        //// leftArrow Drawing
        let leftArrowPath = UIBezierPath()
        leftArrowPath.move(to: CGPoint(x: 0, y: 6))
        leftArrowPath.addLine(to: CGPoint(x: 12, y: 12))
        leftArrowPath.addLine(to: CGPoint(x: 12, y: 0))
        leftArrowPath.addLine(to: CGPoint(x: 0, y: 6))
        leftArrowPath.close()
        UIGroover.popupElements.setFill()
        leftArrowPath.fill()
    }

    public dynamic class func drawRightCanvas() {

        //// rightButton Drawing
        let rightButtonPath = UIBezierPath()
        rightButtonPath.move(to: CGPoint(x: 12, y: 6))
        rightButtonPath.addLine(to: CGPoint(x: 0, y: 12))
        rightButtonPath.addLine(to: CGPoint(x: 0, y: 0))
        rightButtonPath.addLine(to: CGPoint(x: 12, y: 6))
        rightButtonPath.close()
        UIGroover.popupElements.setFill()
        rightButtonPath.fill()
    }

    public dynamic class func drawMeasureCanvas(measureFrame: CGRect = CGRect(x: 0, y: 0, width: 81, height: 28), measureActive: Bool = true, measureProgress: CGFloat = 20) {

        //// Variable Declarations
        let measureActiveColor = measureActive ? UIGroover.lightBlue : UIGroover.measureDark
        let measureActiveFillColor = measureActive ? UIGroover.measureDark : UIGroover.transparent

        //// measureBorder Drawing
        let measureBorderPath = UIBezierPath(roundedRect: CGRect(x: measureFrame.minX + 1, y: measureFrame.minY + 1, width: 79, height: 26), cornerRadius: 2)
        measureActiveFillColor.setFill()
        measureBorderPath.fill()
        measureActiveColor.setStroke()
        measureBorderPath.lineWidth = 2
        measureBorderPath.stroke()


        if (measureActive) {
            //// measureActiveFill Drawing
            let measureActiveFillPath = UIBezierPath(roundedRect: CGRect(x: 1, y: 1, width: measureProgress, height: 26), cornerRadius: 2)
            UIGroover.lightBlue.setFill()
            measureActiveFillPath.fill()
        }
    }

    public dynamic class func drawSliderCanvas(leftArrowFrame: CGRect = CGRect(x: 0, y: 0, width: 44, height: 44), rightArrowFrame: CGRect = CGRect(x: 251, y: 0, width: 44, height: 44), sliderBasicBGFrame: CGRect = CGRect(x: 53, y: 18, width: 188, height: 8), sliderPosition: CGFloat = 0) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let fillColor = UIColor(red: 0.345, green: 0.392, blue: 0.439, alpha: 1.000)

        //// Variable Declarations
        let sliderPositionOffset: CGFloat = sliderPosition + 40

        //// Frames
        let sliderHandleFrame = CGRect(x: sliderPositionOffset, y: 0, width: 44, height: 44)


        //// sliderBasicBG Drawing
        let sliderBasicBGPath = UIBezierPath()
        sliderBasicBGPath.move(to: CGPoint(x: sliderBasicBGFrame.minX, y: sliderBasicBGFrame.minY + 2))
        sliderBasicBGPath.addCurve(to: CGPoint(x: sliderBasicBGFrame.minX + 2.02, y: sliderBasicBGFrame.minY), controlPoint1: CGPoint(x: sliderBasicBGFrame.minX, y: sliderBasicBGFrame.minY + 0.89), controlPoint2: CGPoint(x: sliderBasicBGFrame.minX + 0.9, y: sliderBasicBGFrame.minY))
        sliderBasicBGPath.addLine(to: CGPoint(x: sliderBasicBGFrame.minX + 185.98, y: sliderBasicBGFrame.minY))
        sliderBasicBGPath.addCurve(to: CGPoint(x: sliderBasicBGFrame.minX + 188, y: sliderBasicBGFrame.minY + 2), controlPoint1: CGPoint(x: sliderBasicBGFrame.minX + 187.1, y: sliderBasicBGFrame.minY), controlPoint2: CGPoint(x: sliderBasicBGFrame.minX + 188, y: sliderBasicBGFrame.minY + 0.89))
        sliderBasicBGPath.addLine(to: CGPoint(x: sliderBasicBGFrame.minX + 188, y: sliderBasicBGFrame.minY + 6))
        sliderBasicBGPath.addCurve(to: CGPoint(x: sliderBasicBGFrame.minX + 185.98, y: sliderBasicBGFrame.minY + 8), controlPoint1: CGPoint(x: sliderBasicBGFrame.minX + 188, y: sliderBasicBGFrame.minY + 7.11), controlPoint2: CGPoint(x: sliderBasicBGFrame.minX + 187.1, y: sliderBasicBGFrame.minY + 8))
        sliderBasicBGPath.addLine(to: CGPoint(x: sliderBasicBGFrame.minX + 2.02, y: sliderBasicBGFrame.minY + 8))
        sliderBasicBGPath.addCurve(to: CGPoint(x: sliderBasicBGFrame.minX, y: sliderBasicBGFrame.minY + 6), controlPoint1: CGPoint(x: sliderBasicBGFrame.minX + 0.9, y: sliderBasicBGFrame.minY + 8), controlPoint2: CGPoint(x: sliderBasicBGFrame.minX, y: sliderBasicBGFrame.minY + 7.11))
        sliderBasicBGPath.addLine(to: CGPoint(x: sliderBasicBGFrame.minX, y: sliderBasicBGFrame.minY + 2))
        sliderBasicBGPath.close()
        UIGroover.popupContentLight.setFill()
        sliderBasicBGPath.fill()


        //// sliderBasicBlue Drawing
        context.saveGState()
        context.translateBy(x: sliderBasicBGFrame.minX, y: sliderBasicBGFrame.minY)
        context.scaleBy(x: sliderPosition, y: 1)

        let sliderBasicBluePath = UIBezierPath()
        sliderBasicBluePath.move(to: CGPoint(x: 0, y: 2))
        sliderBasicBluePath.addCurve(to: CGPoint(x: 0.01, y: 0), controlPoint1: CGPoint(x: 0, y: 0.89), controlPoint2: CGPoint(x: 0, y: 0))
        sliderBasicBluePath.addLine(to: CGPoint(x: 0.99, y: 0))
        sliderBasicBluePath.addCurve(to: CGPoint(x: 1, y: 2), controlPoint1: CGPoint(x: 1, y: 0), controlPoint2: CGPoint(x: 1, y: 0.89))
        sliderBasicBluePath.addLine(to: CGPoint(x: 1, y: 6))
        sliderBasicBluePath.addCurve(to: CGPoint(x: 0.99, y: 8), controlPoint1: CGPoint(x: 1, y: 7.11), controlPoint2: CGPoint(x: 1, y: 8))
        sliderBasicBluePath.addLine(to: CGPoint(x: 0.01, y: 8))
        sliderBasicBluePath.addCurve(to: CGPoint(x: 0, y: 6), controlPoint1: CGPoint(x: 0, y: 8), controlPoint2: CGPoint(x: 0, y: 7.11))
        sliderBasicBluePath.addLine(to: CGPoint(x: 0, y: 2))
        sliderBasicBluePath.close()
        UIGroover.lightBlue.setFill()
        sliderBasicBluePath.fill()

        context.restoreGState()


        //// sliderHandle Drawing
        let sliderHandlePath = UIBezierPath(ovalIn: CGRect(x: sliderHandleFrame.minX + 12, y: sliderHandleFrame.minY + 11, width: 21, height: 21))
        UIGroover.white.setFill()
        sliderHandlePath.fill()
        UIGroover.popupContentDark.setStroke()
        sliderHandlePath.lineWidth = 2
        sliderHandlePath.stroke()


        //// leftArrow Drawing
        let leftArrowPath = UIBezierPath()
        leftArrowPath.move(to: CGPoint(x: leftArrowFrame.minX + 14, y: leftArrowFrame.minY + 22))
        leftArrowPath.addLine(to: CGPoint(x: leftArrowFrame.minX + 26, y: leftArrowFrame.minY + 28))
        leftArrowPath.addLine(to: CGPoint(x: leftArrowFrame.minX + 26, y: leftArrowFrame.minY + 16))
        leftArrowPath.addLine(to: CGPoint(x: leftArrowFrame.minX + 14, y: leftArrowFrame.minY + 22))
        leftArrowPath.close()
        fillColor.setFill()
        leftArrowPath.fill()


        //// rightArrow Drawing
        let rightArrowPath = UIBezierPath()
        rightArrowPath.move(to: CGPoint(x: rightArrowFrame.minX + 29, y: rightArrowFrame.minY + 22))
        rightArrowPath.addLine(to: CGPoint(x: rightArrowFrame.minX + 17, y: rightArrowFrame.minY + 28))
        rightArrowPath.addLine(to: CGPoint(x: rightArrowFrame.minX + 17, y: rightArrowFrame.minY + 16))
        rightArrowPath.addLine(to: CGPoint(x: rightArrowFrame.minX + 29, y: rightArrowFrame.minY + 22))
        rightArrowPath.close()
        fillColor.setFill()
        rightArrowPath.fill()
    }

    public dynamic class func drawPanSliderCanvas(leftArrowFrame: CGRect = CGRect(x: 0, y: 0, width: 44, height: 44), rightArrowFrame: CGRect = CGRect(x: 251, y: 0, width: 44, height: 44), sliderBasicBGFrame: CGRect = CGRect(x: 53, y: 18, width: 188, height: 8), panSliderPosition: CGFloat = 2) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let fillColor = UIColor(red: 0.345, green: 0.392, blue: 0.439, alpha: 1.000)

        //// Variable Declarations
        let panSliderPositionOffset: CGFloat = panSliderPosition + 125

        //// Frames
        let sliderHandleFrame = CGRect(x: panSliderPositionOffset, y: 0, width: 44, height: 44)


        //// sliderBasicBG Drawing
        let sliderBasicBGPath = UIBezierPath()
        sliderBasicBGPath.move(to: CGPoint(x: sliderBasicBGFrame.minX, y: sliderBasicBGFrame.minY + 2))
        sliderBasicBGPath.addCurve(to: CGPoint(x: sliderBasicBGFrame.minX + 2.02, y: sliderBasicBGFrame.minY), controlPoint1: CGPoint(x: sliderBasicBGFrame.minX, y: sliderBasicBGFrame.minY + 0.89), controlPoint2: CGPoint(x: sliderBasicBGFrame.minX + 0.9, y: sliderBasicBGFrame.minY))
        sliderBasicBGPath.addLine(to: CGPoint(x: sliderBasicBGFrame.minX + 185.98, y: sliderBasicBGFrame.minY))
        sliderBasicBGPath.addCurve(to: CGPoint(x: sliderBasicBGFrame.minX + 188, y: sliderBasicBGFrame.minY + 2), controlPoint1: CGPoint(x: sliderBasicBGFrame.minX + 187.1, y: sliderBasicBGFrame.minY), controlPoint2: CGPoint(x: sliderBasicBGFrame.minX + 188, y: sliderBasicBGFrame.minY + 0.89))
        sliderBasicBGPath.addLine(to: CGPoint(x: sliderBasicBGFrame.minX + 188, y: sliderBasicBGFrame.minY + 6))
        sliderBasicBGPath.addCurve(to: CGPoint(x: sliderBasicBGFrame.minX + 185.98, y: sliderBasicBGFrame.minY + 8), controlPoint1: CGPoint(x: sliderBasicBGFrame.minX + 188, y: sliderBasicBGFrame.minY + 7.11), controlPoint2: CGPoint(x: sliderBasicBGFrame.minX + 187.1, y: sliderBasicBGFrame.minY + 8))
        sliderBasicBGPath.addLine(to: CGPoint(x: sliderBasicBGFrame.minX + 2.02, y: sliderBasicBGFrame.minY + 8))
        sliderBasicBGPath.addCurve(to: CGPoint(x: sliderBasicBGFrame.minX, y: sliderBasicBGFrame.minY + 6), controlPoint1: CGPoint(x: sliderBasicBGFrame.minX + 0.9, y: sliderBasicBGFrame.minY + 8), controlPoint2: CGPoint(x: sliderBasicBGFrame.minX, y: sliderBasicBGFrame.minY + 7.11))
        sliderBasicBGPath.addLine(to: CGPoint(x: sliderBasicBGFrame.minX, y: sliderBasicBGFrame.minY + 2))
        sliderBasicBGPath.close()
        UIGroover.popupContentLight.setFill()
        sliderBasicBGPath.fill()


        //// sliderPanBlue Drawing
        context.saveGState()
        context.translateBy(x: sliderBasicBGFrame.minX + 94, y: sliderBasicBGFrame.minY)
        context.scaleBy(x: panSliderPosition, y: 1)

        let sliderPanBluePath = UIBezierPath()
        sliderPanBluePath.move(to: CGPoint(x: 0, y: 2))
        sliderPanBluePath.addCurve(to: CGPoint(x: 0.01, y: 0), controlPoint1: CGPoint(x: 0, y: 0.89), controlPoint2: CGPoint(x: 0, y: 0))
        sliderPanBluePath.addLine(to: CGPoint(x: 0.99, y: 0))
        sliderPanBluePath.addCurve(to: CGPoint(x: 1, y: 2), controlPoint1: CGPoint(x: 1, y: 0), controlPoint2: CGPoint(x: 1, y: 0.89))
        sliderPanBluePath.addLine(to: CGPoint(x: 1, y: 6))
        sliderPanBluePath.addCurve(to: CGPoint(x: 0.99, y: 8), controlPoint1: CGPoint(x: 1, y: 7.11), controlPoint2: CGPoint(x: 1, y: 8))
        sliderPanBluePath.addLine(to: CGPoint(x: 0.01, y: 8))
        sliderPanBluePath.addCurve(to: CGPoint(x: 0, y: 6), controlPoint1: CGPoint(x: 0, y: 8), controlPoint2: CGPoint(x: 0, y: 7.11))
        sliderPanBluePath.addLine(to: CGPoint(x: 0, y: 2))
        sliderPanBluePath.close()
        UIGroover.lightBlue.setFill()
        sliderPanBluePath.fill()

        context.restoreGState()


        //// sliderHandle Drawing
        let sliderHandlePath = UIBezierPath(ovalIn: CGRect(x: sliderHandleFrame.minX + 12, y: sliderHandleFrame.minY + 11, width: 21, height: 21))
        UIGroover.white.setFill()
        sliderHandlePath.fill()
        UIGroover.popupContentDark.setStroke()
        sliderHandlePath.lineWidth = 2
        sliderHandlePath.stroke()


        //// leftArrow Drawing
        let leftArrowPath = UIBezierPath()
        leftArrowPath.move(to: CGPoint(x: leftArrowFrame.minX + 14, y: leftArrowFrame.minY + 22))
        leftArrowPath.addLine(to: CGPoint(x: leftArrowFrame.minX + 26, y: leftArrowFrame.minY + 28))
        leftArrowPath.addLine(to: CGPoint(x: leftArrowFrame.minX + 26, y: leftArrowFrame.minY + 16))
        leftArrowPath.addLine(to: CGPoint(x: leftArrowFrame.minX + 14, y: leftArrowFrame.minY + 22))
        leftArrowPath.close()
        fillColor.setFill()
        leftArrowPath.fill()


        //// rightArrow Drawing
        let rightArrowPath = UIBezierPath()
        rightArrowPath.move(to: CGPoint(x: rightArrowFrame.minX + 29, y: rightArrowFrame.minY + 22))
        rightArrowPath.addLine(to: CGPoint(x: rightArrowFrame.minX + 17, y: rightArrowFrame.minY + 28))
        rightArrowPath.addLine(to: CGPoint(x: rightArrowFrame.minX + 17, y: rightArrowFrame.minY + 16))
        rightArrowPath.addLine(to: CGPoint(x: rightArrowFrame.minX + 29, y: rightArrowFrame.minY + 22))
        rightArrowPath.close()
        fillColor.setFill()
        rightArrowPath.fill()
    }

    public dynamic class func drawQuarterCanvas(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 54, height: 54), resizing: ResizingBehavior = .aspectFit, quarterSelected: Bool = false, quarterActive: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 54, height: 54), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 54, y: resizedFrame.height / 54)



        //// Variable Declarations
        let quarterDeselected = !quarterSelected

        //// Frames
        let quarterFrame = CGRect(x: 0, y: 0, width: 54, height: 54)


        //// quarterButton
        if (quarterActive) {
            //// buttonBlue Drawing
            let buttonBluePath = UIBezierPath(roundedRect: CGRect(x: quarterFrame.minX, y: quarterFrame.minY, width: 54, height: 54), cornerRadius: 6)
            UIGroover.lightBlue.setFill()
            buttonBluePath.fill()
        }


        if (quarterSelected) {
            //// buttonOutline Drawing
            let buttonOutlinePath = UIBezierPath(roundedRect: CGRect(x: quarterFrame.minX, y: quarterFrame.minY, width: 54, height: 54), cornerRadius: 6)
            UIGroover.lightBlue.setStroke()
            buttonOutlinePath.lineWidth = 2
            buttonOutlinePath.stroke()
        }


        if (quarterDeselected) {
            //// buttonBlack Drawing
            let buttonBlackPath = UIBezierPath(roundedRect: CGRect(x: quarterFrame.minX + 5, y: quarterFrame.minY + 5, width: 44, height: 44), cornerRadius: 6)
            UIGroover.black.setFill()
            buttonBlackPath.fill()


            //// quarterLight Drawing
            let quarterLightPath = UIBezierPath()
            quarterLightPath.move(to: CGPoint(x: quarterFrame.minX + 31.46, y: quarterFrame.minY + 34))
            quarterLightPath.addCurve(to: CGPoint(x: quarterFrame.minX + 26.55, y: quarterFrame.minY + 37.86), controlPoint1: CGPoint(x: quarterFrame.minX + 31.36, y: quarterFrame.minY + 35.27), controlPoint2: CGPoint(x: quarterFrame.minX + 29.33, y: quarterFrame.minY + 36.9))
            quarterLightPath.addCurve(to: CGPoint(x: quarterFrame.minX + 20.06, y: quarterFrame.minY + 37.45), controlPoint1: CGPoint(x: quarterFrame.minX + 23.41, y: quarterFrame.minY + 38.94), controlPoint2: CGPoint(x: quarterFrame.minX + 20.51, y: quarterFrame.minY + 38.76))
            quarterLightPath.addCurve(to: CGPoint(x: quarterFrame.minX + 24.92, y: quarterFrame.minY + 33.14), controlPoint1: CGPoint(x: quarterFrame.minX + 19.61, y: quarterFrame.minY + 36.15), controlPoint2: CGPoint(x: quarterFrame.minX + 21.78, y: quarterFrame.minY + 34.22))
            quarterLightPath.addCurve(to: CGPoint(x: quarterFrame.minX + 29.48, y: quarterFrame.minY + 32.48), controlPoint1: CGPoint(x: quarterFrame.minX + 26.63, y: quarterFrame.minY + 32.55), controlPoint2: CGPoint(x: quarterFrame.minX + 28.27, y: quarterFrame.minY + 32.33))
            quarterLightPath.addLine(to: CGPoint(x: quarterFrame.minX + 29.48, y: quarterFrame.minY + 14))
            quarterLightPath.addLine(to: CGPoint(x: quarterFrame.minX + 31.48, y: quarterFrame.minY + 14))
            quarterLightPath.addLine(to: CGPoint(x: quarterFrame.minX + 31.48, y: quarterFrame.minY + 34))
            quarterLightPath.addLine(to: CGPoint(x: quarterFrame.minX + 31.46, y: quarterFrame.minY + 34))
            quarterLightPath.addLine(to: CGPoint(x: quarterFrame.minX + 31.46, y: quarterFrame.minY + 34))
            quarterLightPath.close()
            UIGroover.noteGray.setFill()
            quarterLightPath.fill()
        }


        if (quarterActive) {
            //// quarterDark Drawing
            let quarterDarkPath = UIBezierPath()
            quarterDarkPath.move(to: CGPoint(x: quarterFrame.minX + 31.46, y: quarterFrame.minY + 34))
            quarterDarkPath.addCurve(to: CGPoint(x: quarterFrame.minX + 26.55, y: quarterFrame.minY + 37.86), controlPoint1: CGPoint(x: quarterFrame.minX + 31.36, y: quarterFrame.minY + 35.27), controlPoint2: CGPoint(x: quarterFrame.minX + 29.33, y: quarterFrame.minY + 36.9))
            quarterDarkPath.addCurve(to: CGPoint(x: quarterFrame.minX + 20.06, y: quarterFrame.minY + 37.45), controlPoint1: CGPoint(x: quarterFrame.minX + 23.41, y: quarterFrame.minY + 38.94), controlPoint2: CGPoint(x: quarterFrame.minX + 20.51, y: quarterFrame.minY + 38.76))
            quarterDarkPath.addCurve(to: CGPoint(x: quarterFrame.minX + 24.92, y: quarterFrame.minY + 33.14), controlPoint1: CGPoint(x: quarterFrame.minX + 19.61, y: quarterFrame.minY + 36.15), controlPoint2: CGPoint(x: quarterFrame.minX + 21.78, y: quarterFrame.minY + 34.22))
            quarterDarkPath.addCurve(to: CGPoint(x: quarterFrame.minX + 29.48, y: quarterFrame.minY + 32.48), controlPoint1: CGPoint(x: quarterFrame.minX + 26.63, y: quarterFrame.minY + 32.55), controlPoint2: CGPoint(x: quarterFrame.minX + 28.27, y: quarterFrame.minY + 32.33))
            quarterDarkPath.addLine(to: CGPoint(x: quarterFrame.minX + 29.48, y: quarterFrame.minY + 14))
            quarterDarkPath.addLine(to: CGPoint(x: quarterFrame.minX + 31.48, y: quarterFrame.minY + 14))
            quarterDarkPath.addLine(to: CGPoint(x: quarterFrame.minX + 31.48, y: quarterFrame.minY + 34))
            quarterDarkPath.addLine(to: CGPoint(x: quarterFrame.minX + 31.46, y: quarterFrame.minY + 34))
            quarterDarkPath.addLine(to: CGPoint(x: quarterFrame.minX + 31.46, y: quarterFrame.minY + 34))
            quarterDarkPath.close()
            UIGroover.noteDark.setFill()
            quarterDarkPath.fill()
        }


        if (quarterSelected) {
            //// quarterBlue Drawing
            let quarterBluePath = UIBezierPath()
            quarterBluePath.move(to: CGPoint(x: quarterFrame.minX + 31.46, y: quarterFrame.minY + 34))
            quarterBluePath.addCurve(to: CGPoint(x: quarterFrame.minX + 26.55, y: quarterFrame.minY + 37.86), controlPoint1: CGPoint(x: quarterFrame.minX + 31.36, y: quarterFrame.minY + 35.27), controlPoint2: CGPoint(x: quarterFrame.minX + 29.33, y: quarterFrame.minY + 36.9))
            quarterBluePath.addCurve(to: CGPoint(x: quarterFrame.minX + 20.06, y: quarterFrame.minY + 37.45), controlPoint1: CGPoint(x: quarterFrame.minX + 23.41, y: quarterFrame.minY + 38.94), controlPoint2: CGPoint(x: quarterFrame.minX + 20.51, y: quarterFrame.minY + 38.76))
            quarterBluePath.addCurve(to: CGPoint(x: quarterFrame.minX + 24.92, y: quarterFrame.minY + 33.14), controlPoint1: CGPoint(x: quarterFrame.minX + 19.61, y: quarterFrame.minY + 36.15), controlPoint2: CGPoint(x: quarterFrame.minX + 21.78, y: quarterFrame.minY + 34.22))
            quarterBluePath.addCurve(to: CGPoint(x: quarterFrame.minX + 29.48, y: quarterFrame.minY + 32.48), controlPoint1: CGPoint(x: quarterFrame.minX + 26.63, y: quarterFrame.minY + 32.55), controlPoint2: CGPoint(x: quarterFrame.minX + 28.27, y: quarterFrame.minY + 32.33))
            quarterBluePath.addLine(to: CGPoint(x: quarterFrame.minX + 29.48, y: quarterFrame.minY + 14))
            quarterBluePath.addLine(to: CGPoint(x: quarterFrame.minX + 31.48, y: quarterFrame.minY + 14))
            quarterBluePath.addLine(to: CGPoint(x: quarterFrame.minX + 31.48, y: quarterFrame.minY + 34))
            quarterBluePath.addLine(to: CGPoint(x: quarterFrame.minX + 31.46, y: quarterFrame.minY + 34))
            quarterBluePath.addLine(to: CGPoint(x: quarterFrame.minX + 31.46, y: quarterFrame.minY + 34))
            quarterBluePath.close()
            UIGroover.lightBlue.setFill()
            quarterBluePath.fill()
        }
        
        context.restoreGState()

    }

    public dynamic class func drawEighthCanvas(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 54, height: 54), resizing: ResizingBehavior = .aspectFit, eighthSelected: Bool = false, eighthActive: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 54, height: 54), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 54, y: resizedFrame.height / 54)



        //// Variable Declarations
        let eighthDeselected = !eighthSelected

        //// Frames
        let eighthFrame = CGRect(x: 0, y: 0, width: 54, height: 54)


        //// eighthButton
        if (eighthActive) {
            //// buttonBlue 3 Drawing
            let buttonBlue3Path = UIBezierPath(roundedRect: CGRect(x: eighthFrame.minX, y: eighthFrame.minY, width: 54, height: 54), cornerRadius: 6)
            UIGroover.lightBlue.setFill()
            buttonBlue3Path.fill()
        }


        if (eighthSelected) {
            //// buttonOutline 3 Drawing
            let buttonOutline3Path = UIBezierPath(roundedRect: CGRect(x: eighthFrame.minX, y: eighthFrame.minY, width: 54, height: 54), cornerRadius: 6)
            UIGroover.lightBlue.setStroke()
            buttonOutline3Path.lineWidth = 2
            buttonOutline3Path.stroke()
        }


        if (eighthDeselected) {
            //// buttonBlack 3 Drawing
            let buttonBlack3Path = UIBezierPath(roundedRect: CGRect(x: eighthFrame.minX + 5, y: eighthFrame.minY + 5, width: 44, height: 44), cornerRadius: 6)
            UIGroover.black.setFill()
            buttonBlack3Path.fill()


            //// eighthLight Drawing
            let eighthLightPath = UIBezierPath()
            eighthLightPath.move(to: CGPoint(x: eighthFrame.minX + 30.61, y: eighthFrame.minY + 14))
            eighthLightPath.addLine(to: CGPoint(x: eighthFrame.minX + 29.48, y: eighthFrame.minY + 14))
            eighthLightPath.addLine(to: CGPoint(x: eighthFrame.minX + 29.48, y: eighthFrame.minY + 32.48))
            eighthLightPath.addCurve(to: CGPoint(x: eighthFrame.minX + 24.92, y: eighthFrame.minY + 33.14), controlPoint1: CGPoint(x: eighthFrame.minX + 28.27, y: eighthFrame.minY + 32.33), controlPoint2: CGPoint(x: eighthFrame.minX + 26.63, y: eighthFrame.minY + 32.55))
            eighthLightPath.addCurve(to: CGPoint(x: eighthFrame.minX + 20.06, y: eighthFrame.minY + 37.45), controlPoint1: CGPoint(x: eighthFrame.minX + 21.78, y: eighthFrame.minY + 34.22), controlPoint2: CGPoint(x: eighthFrame.minX + 19.61, y: eighthFrame.minY + 36.15))
            eighthLightPath.addCurve(to: CGPoint(x: eighthFrame.minX + 26.55, y: eighthFrame.minY + 37.86), controlPoint1: CGPoint(x: eighthFrame.minX + 20.51, y: eighthFrame.minY + 38.76), controlPoint2: CGPoint(x: eighthFrame.minX + 23.41, y: eighthFrame.minY + 38.94))
            eighthLightPath.addCurve(to: CGPoint(x: eighthFrame.minX + 31.46, y: eighthFrame.minY + 34), controlPoint1: CGPoint(x: eighthFrame.minX + 29.33, y: eighthFrame.minY + 36.9), controlPoint2: CGPoint(x: eighthFrame.minX + 31.36, y: eighthFrame.minY + 35.27))
            eighthLightPath.addLine(to: CGPoint(x: eighthFrame.minX + 31.46, y: eighthFrame.minY + 34))
            eighthLightPath.addLine(to: CGPoint(x: eighthFrame.minX + 31.48, y: eighthFrame.minY + 34))
            eighthLightPath.addLine(to: CGPoint(x: eighthFrame.minX + 31.48, y: eighthFrame.minY + 18))
            eighthLightPath.addLine(to: CGPoint(x: eighthFrame.minX + 37.73, y: eighthFrame.minY + 18))
            eighthLightPath.addLine(to: CGPoint(x: eighthFrame.minX + 37.73, y: eighthFrame.minY + 14))
            eighthLightPath.addLine(to: CGPoint(x: eighthFrame.minX + 30.61, y: eighthFrame.minY + 14))
            eighthLightPath.addLine(to: CGPoint(x: eighthFrame.minX + 30.61, y: eighthFrame.minY + 14))
            eighthLightPath.close()
            UIGroover.noteGray.setFill()
            eighthLightPath.fill()
        }


        if (eighthActive) {
            //// eighthDark Drawing
            let eighthDarkPath = UIBezierPath()
            eighthDarkPath.move(to: CGPoint(x: eighthFrame.minX + 30.61, y: eighthFrame.minY + 14))
            eighthDarkPath.addLine(to: CGPoint(x: eighthFrame.minX + 29.48, y: eighthFrame.minY + 14))
            eighthDarkPath.addLine(to: CGPoint(x: eighthFrame.minX + 29.48, y: eighthFrame.minY + 32.48))
            eighthDarkPath.addCurve(to: CGPoint(x: eighthFrame.minX + 24.92, y: eighthFrame.minY + 33.14), controlPoint1: CGPoint(x: eighthFrame.minX + 28.27, y: eighthFrame.minY + 32.33), controlPoint2: CGPoint(x: eighthFrame.minX + 26.63, y: eighthFrame.minY + 32.55))
            eighthDarkPath.addCurve(to: CGPoint(x: eighthFrame.minX + 20.06, y: eighthFrame.minY + 37.45), controlPoint1: CGPoint(x: eighthFrame.minX + 21.78, y: eighthFrame.minY + 34.22), controlPoint2: CGPoint(x: eighthFrame.minX + 19.61, y: eighthFrame.minY + 36.15))
            eighthDarkPath.addCurve(to: CGPoint(x: eighthFrame.minX + 26.55, y: eighthFrame.minY + 37.86), controlPoint1: CGPoint(x: eighthFrame.minX + 20.51, y: eighthFrame.minY + 38.76), controlPoint2: CGPoint(x: eighthFrame.minX + 23.41, y: eighthFrame.minY + 38.94))
            eighthDarkPath.addCurve(to: CGPoint(x: eighthFrame.minX + 31.46, y: eighthFrame.minY + 34), controlPoint1: CGPoint(x: eighthFrame.minX + 29.33, y: eighthFrame.minY + 36.9), controlPoint2: CGPoint(x: eighthFrame.minX + 31.36, y: eighthFrame.minY + 35.27))
            eighthDarkPath.addLine(to: CGPoint(x: eighthFrame.minX + 31.46, y: eighthFrame.minY + 34))
            eighthDarkPath.addLine(to: CGPoint(x: eighthFrame.minX + 31.48, y: eighthFrame.minY + 34))
            eighthDarkPath.addLine(to: CGPoint(x: eighthFrame.minX + 31.48, y: eighthFrame.minY + 18))
            eighthDarkPath.addLine(to: CGPoint(x: eighthFrame.minX + 37.73, y: eighthFrame.minY + 18))
            eighthDarkPath.addLine(to: CGPoint(x: eighthFrame.minX + 37.73, y: eighthFrame.minY + 14))
            eighthDarkPath.addLine(to: CGPoint(x: eighthFrame.minX + 30.61, y: eighthFrame.minY + 14))
            eighthDarkPath.addLine(to: CGPoint(x: eighthFrame.minX + 30.61, y: eighthFrame.minY + 14))
            eighthDarkPath.close()
            UIGroover.noteDark.setFill()
            eighthDarkPath.fill()
        }


        if (eighthSelected) {
            //// eighthBlue Drawing
            let eighthBluePath = UIBezierPath()
            eighthBluePath.move(to: CGPoint(x: eighthFrame.minX + 30.61, y: eighthFrame.minY + 14))
            eighthBluePath.addLine(to: CGPoint(x: eighthFrame.minX + 29.48, y: eighthFrame.minY + 14))
            eighthBluePath.addLine(to: CGPoint(x: eighthFrame.minX + 29.48, y: eighthFrame.minY + 32.48))
            eighthBluePath.addCurve(to: CGPoint(x: eighthFrame.minX + 24.92, y: eighthFrame.minY + 33.14), controlPoint1: CGPoint(x: eighthFrame.minX + 28.27, y: eighthFrame.minY + 32.33), controlPoint2: CGPoint(x: eighthFrame.minX + 26.63, y: eighthFrame.minY + 32.55))
            eighthBluePath.addCurve(to: CGPoint(x: eighthFrame.minX + 20.06, y: eighthFrame.minY + 37.45), controlPoint1: CGPoint(x: eighthFrame.minX + 21.78, y: eighthFrame.minY + 34.22), controlPoint2: CGPoint(x: eighthFrame.minX + 19.61, y: eighthFrame.minY + 36.15))
            eighthBluePath.addCurve(to: CGPoint(x: eighthFrame.minX + 26.55, y: eighthFrame.minY + 37.86), controlPoint1: CGPoint(x: eighthFrame.minX + 20.51, y: eighthFrame.minY + 38.76), controlPoint2: CGPoint(x: eighthFrame.minX + 23.41, y: eighthFrame.minY + 38.94))
            eighthBluePath.addCurve(to: CGPoint(x: eighthFrame.minX + 31.46, y: eighthFrame.minY + 34), controlPoint1: CGPoint(x: eighthFrame.minX + 29.33, y: eighthFrame.minY + 36.9), controlPoint2: CGPoint(x: eighthFrame.minX + 31.36, y: eighthFrame.minY + 35.27))
            eighthBluePath.addLine(to: CGPoint(x: eighthFrame.minX + 31.46, y: eighthFrame.minY + 34))
            eighthBluePath.addLine(to: CGPoint(x: eighthFrame.minX + 31.48, y: eighthFrame.minY + 34))
            eighthBluePath.addLine(to: CGPoint(x: eighthFrame.minX + 31.48, y: eighthFrame.minY + 18))
            eighthBluePath.addLine(to: CGPoint(x: eighthFrame.minX + 37.73, y: eighthFrame.minY + 18))
            eighthBluePath.addLine(to: CGPoint(x: eighthFrame.minX + 37.73, y: eighthFrame.minY + 14))
            eighthBluePath.addLine(to: CGPoint(x: eighthFrame.minX + 30.61, y: eighthFrame.minY + 14))
            eighthBluePath.addLine(to: CGPoint(x: eighthFrame.minX + 30.61, y: eighthFrame.minY + 14))
            eighthBluePath.close()
            UIGroover.lightBlue.setFill()
            eighthBluePath.fill()
        }
        
        context.restoreGState()

    }

    public dynamic class func drawSixteenthCanvas(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 54, height: 54), resizing: ResizingBehavior = .aspectFit, sixteenthSelected: Bool = false, sixteenthActive: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 54, height: 54), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 54, y: resizedFrame.height / 54)



        //// Variable Declarations
        let sixteenthDeselected = !sixteenthSelected

        //// Frames
        let frame = CGRect(x: 0, y: 0, width: 54, height: 54)


        //// sixteenthButton
        if (sixteenthActive) {
            //// buttonBlue 4 Drawing
            let buttonBlue4Path = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY, width: 54, height: 54), cornerRadius: 6)
            UIGroover.lightBlue.setFill()
            buttonBlue4Path.fill()
        }


        if (sixteenthSelected) {
            //// buttonOutline 4 Drawing
            let buttonOutline4Path = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY, width: 54, height: 54), cornerRadius: 6)
            UIGroover.lightBlue.setStroke()
            buttonOutline4Path.lineWidth = 2
            buttonOutline4Path.stroke()
        }


        if (sixteenthDeselected) {
            //// buttonBlack 4 Drawing
            let buttonBlack4Path = UIBezierPath(roundedRect: CGRect(x: frame.minX + 5, y: frame.minY + 5, width: 44, height: 44), cornerRadius: 6)
            UIGroover.black.setFill()
            buttonBlack4Path.fill()


            //// sixteenthLight Drawing
            let sixteenthLightPath = UIBezierPath()
            sixteenthLightPath.move(to: CGPoint(x: frame.minX + 31.48, y: frame.minY + 25))
            sixteenthLightPath.addLine(to: CGPoint(x: frame.minX + 31.48, y: frame.minY + 34))
            sixteenthLightPath.addLine(to: CGPoint(x: frame.minX + 31.46, y: frame.minY + 34))
            sixteenthLightPath.addLine(to: CGPoint(x: frame.minX + 31.46, y: frame.minY + 34))
            sixteenthLightPath.addCurve(to: CGPoint(x: frame.minX + 26.55, y: frame.minY + 37.86), controlPoint1: CGPoint(x: frame.minX + 31.36, y: frame.minY + 35.27), controlPoint2: CGPoint(x: frame.minX + 29.33, y: frame.minY + 36.9))
            sixteenthLightPath.addCurve(to: CGPoint(x: frame.minX + 20.06, y: frame.minY + 37.45), controlPoint1: CGPoint(x: frame.minX + 23.41, y: frame.minY + 38.94), controlPoint2: CGPoint(x: frame.minX + 20.51, y: frame.minY + 38.76))
            sixteenthLightPath.addCurve(to: CGPoint(x: frame.minX + 24.92, y: frame.minY + 33.14), controlPoint1: CGPoint(x: frame.minX + 19.61, y: frame.minY + 36.15), controlPoint2: CGPoint(x: frame.minX + 21.78, y: frame.minY + 34.22))
            sixteenthLightPath.addCurve(to: CGPoint(x: frame.minX + 29.48, y: frame.minY + 32.48), controlPoint1: CGPoint(x: frame.minX + 26.63, y: frame.minY + 32.55), controlPoint2: CGPoint(x: frame.minX + 28.27, y: frame.minY + 32.33))
            sixteenthLightPath.addLine(to: CGPoint(x: frame.minX + 29.48, y: frame.minY + 14))
            sixteenthLightPath.addLine(to: CGPoint(x: frame.minX + 30.61, y: frame.minY + 14))
            sixteenthLightPath.addLine(to: CGPoint(x: frame.minX + 30.61, y: frame.minY + 14))
            sixteenthLightPath.addLine(to: CGPoint(x: frame.minX + 37.73, y: frame.minY + 14))
            sixteenthLightPath.addLine(to: CGPoint(x: frame.minX + 37.73, y: frame.minY + 18))
            sixteenthLightPath.addLine(to: CGPoint(x: frame.minX + 31.48, y: frame.minY + 18))
            sixteenthLightPath.addLine(to: CGPoint(x: frame.minX + 31.48, y: frame.minY + 21))
            sixteenthLightPath.addLine(to: CGPoint(x: frame.minX + 37.73, y: frame.minY + 21))
            sixteenthLightPath.addLine(to: CGPoint(x: frame.minX + 37.73, y: frame.minY + 25))
            sixteenthLightPath.addLine(to: CGPoint(x: frame.minX + 31.48, y: frame.minY + 25))
            sixteenthLightPath.addLine(to: CGPoint(x: frame.minX + 31.48, y: frame.minY + 25))
            sixteenthLightPath.close()
            UIGroover.noteGray.setFill()
            sixteenthLightPath.fill()
        }


        if (sixteenthActive) {
            //// sixteenthDark Drawing
            let sixteenthDarkPath = UIBezierPath()
            sixteenthDarkPath.move(to: CGPoint(x: frame.minX + 31.48, y: frame.minY + 25))
            sixteenthDarkPath.addLine(to: CGPoint(x: frame.minX + 31.48, y: frame.minY + 34))
            sixteenthDarkPath.addLine(to: CGPoint(x: frame.minX + 31.46, y: frame.minY + 34))
            sixteenthDarkPath.addLine(to: CGPoint(x: frame.minX + 31.46, y: frame.minY + 34))
            sixteenthDarkPath.addCurve(to: CGPoint(x: frame.minX + 26.55, y: frame.minY + 37.86), controlPoint1: CGPoint(x: frame.minX + 31.36, y: frame.minY + 35.27), controlPoint2: CGPoint(x: frame.minX + 29.33, y: frame.minY + 36.9))
            sixteenthDarkPath.addCurve(to: CGPoint(x: frame.minX + 20.06, y: frame.minY + 37.45), controlPoint1: CGPoint(x: frame.minX + 23.41, y: frame.minY + 38.94), controlPoint2: CGPoint(x: frame.minX + 20.51, y: frame.minY + 38.76))
            sixteenthDarkPath.addCurve(to: CGPoint(x: frame.minX + 24.92, y: frame.minY + 33.14), controlPoint1: CGPoint(x: frame.minX + 19.61, y: frame.minY + 36.15), controlPoint2: CGPoint(x: frame.minX + 21.78, y: frame.minY + 34.22))
            sixteenthDarkPath.addCurve(to: CGPoint(x: frame.minX + 29.48, y: frame.minY + 32.48), controlPoint1: CGPoint(x: frame.minX + 26.63, y: frame.minY + 32.55), controlPoint2: CGPoint(x: frame.minX + 28.27, y: frame.minY + 32.33))
            sixteenthDarkPath.addLine(to: CGPoint(x: frame.minX + 29.48, y: frame.minY + 14))
            sixteenthDarkPath.addLine(to: CGPoint(x: frame.minX + 30.61, y: frame.minY + 14))
            sixteenthDarkPath.addLine(to: CGPoint(x: frame.minX + 30.61, y: frame.minY + 14))
            sixteenthDarkPath.addLine(to: CGPoint(x: frame.minX + 37.73, y: frame.minY + 14))
            sixteenthDarkPath.addLine(to: CGPoint(x: frame.minX + 37.73, y: frame.minY + 18))
            sixteenthDarkPath.addLine(to: CGPoint(x: frame.minX + 31.48, y: frame.minY + 18))
            sixteenthDarkPath.addLine(to: CGPoint(x: frame.minX + 31.48, y: frame.minY + 21))
            sixteenthDarkPath.addLine(to: CGPoint(x: frame.minX + 37.73, y: frame.minY + 21))
            sixteenthDarkPath.addLine(to: CGPoint(x: frame.minX + 37.73, y: frame.minY + 25))
            sixteenthDarkPath.addLine(to: CGPoint(x: frame.minX + 31.48, y: frame.minY + 25))
            sixteenthDarkPath.addLine(to: CGPoint(x: frame.minX + 31.48, y: frame.minY + 25))
            sixteenthDarkPath.close()
            UIGroover.noteDark.setFill()
            sixteenthDarkPath.fill()
        }


        if (sixteenthSelected) {
            //// sixteenthBlue Drawing
            let sixteenthBluePath = UIBezierPath()
            sixteenthBluePath.move(to: CGPoint(x: frame.minX + 31.48, y: frame.minY + 25))
            sixteenthBluePath.addLine(to: CGPoint(x: frame.minX + 31.48, y: frame.minY + 34))
            sixteenthBluePath.addLine(to: CGPoint(x: frame.minX + 31.46, y: frame.minY + 34))
            sixteenthBluePath.addLine(to: CGPoint(x: frame.minX + 31.46, y: frame.minY + 34))
            sixteenthBluePath.addCurve(to: CGPoint(x: frame.minX + 26.55, y: frame.minY + 37.86), controlPoint1: CGPoint(x: frame.minX + 31.36, y: frame.minY + 35.27), controlPoint2: CGPoint(x: frame.minX + 29.33, y: frame.minY + 36.9))
            sixteenthBluePath.addCurve(to: CGPoint(x: frame.minX + 20.06, y: frame.minY + 37.45), controlPoint1: CGPoint(x: frame.minX + 23.41, y: frame.minY + 38.94), controlPoint2: CGPoint(x: frame.minX + 20.51, y: frame.minY + 38.76))
            sixteenthBluePath.addCurve(to: CGPoint(x: frame.minX + 24.92, y: frame.minY + 33.14), controlPoint1: CGPoint(x: frame.minX + 19.61, y: frame.minY + 36.15), controlPoint2: CGPoint(x: frame.minX + 21.78, y: frame.minY + 34.22))
            sixteenthBluePath.addCurve(to: CGPoint(x: frame.minX + 29.48, y: frame.minY + 32.48), controlPoint1: CGPoint(x: frame.minX + 26.63, y: frame.minY + 32.55), controlPoint2: CGPoint(x: frame.minX + 28.27, y: frame.minY + 32.33))
            sixteenthBluePath.addLine(to: CGPoint(x: frame.minX + 29.48, y: frame.minY + 14))
            sixteenthBluePath.addLine(to: CGPoint(x: frame.minX + 30.61, y: frame.minY + 14))
            sixteenthBluePath.addLine(to: CGPoint(x: frame.minX + 30.61, y: frame.minY + 14))
            sixteenthBluePath.addLine(to: CGPoint(x: frame.minX + 37.73, y: frame.minY + 14))
            sixteenthBluePath.addLine(to: CGPoint(x: frame.minX + 37.73, y: frame.minY + 18))
            sixteenthBluePath.addLine(to: CGPoint(x: frame.minX + 31.48, y: frame.minY + 18))
            sixteenthBluePath.addLine(to: CGPoint(x: frame.minX + 31.48, y: frame.minY + 21))
            sixteenthBluePath.addLine(to: CGPoint(x: frame.minX + 37.73, y: frame.minY + 21))
            sixteenthBluePath.addLine(to: CGPoint(x: frame.minX + 37.73, y: frame.minY + 25))
            sixteenthBluePath.addLine(to: CGPoint(x: frame.minX + 31.48, y: frame.minY + 25))
            sixteenthBluePath.addLine(to: CGPoint(x: frame.minX + 31.48, y: frame.minY + 25))
            sixteenthBluePath.close()
            UIGroover.lightBlue.setFill()
            sixteenthBluePath.fill()
        }
        
        context.restoreGState()

    }

    public dynamic class func drawThirtysecondCanvas(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 54, height: 54), resizing: ResizingBehavior = .aspectFit, thirtysecondSelected: Bool = false, thirtysecondActive: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 54, height: 54), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 54, y: resizedFrame.height / 54)



        //// Variable Declarations
        let thirtysecondDeselected = !thirtysecondSelected

        //// Frames
        let thirtySecondFrame = CGRect(x: 0, y: 0, width: 54, height: 54)


        //// thirtySecondButton
        if (thirtysecondActive) {
            //// buttonBlue 5 Drawing
            let buttonBlue5Path = UIBezierPath(roundedRect: CGRect(x: thirtySecondFrame.minX, y: thirtySecondFrame.minY, width: 54, height: 54), cornerRadius: 6)
            UIGroover.lightBlue.setFill()
            buttonBlue5Path.fill()
        }


        if (thirtysecondSelected) {
            //// buttonOutline 5 Drawing
            let buttonOutline5Path = UIBezierPath(roundedRect: CGRect(x: thirtySecondFrame.minX, y: thirtySecondFrame.minY, width: 54, height: 54), cornerRadius: 6)
            UIGroover.lightBlue.setStroke()
            buttonOutline5Path.lineWidth = 2
            buttonOutline5Path.stroke()
        }


        if (thirtysecondDeselected) {
            //// buttonBlack 5 Drawing
            let buttonBlack5Path = UIBezierPath(roundedRect: CGRect(x: thirtySecondFrame.minX + 5, y: thirtySecondFrame.minY + 5, width: 44, height: 44), cornerRadius: 6)
            UIGroover.black.setFill()
            buttonBlack5Path.fill()


            //// thirtysecondLight Drawing
            let thirtysecondLightPath = UIBezierPath()
            thirtysecondLightPath.move(to: CGPoint(x: thirtySecondFrame.minX + 31.5, y: thirtySecondFrame.minY + 24))
            thirtysecondLightPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.5, y: thirtySecondFrame.minY + 22))
            thirtysecondLightPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 37.5, y: thirtySecondFrame.minY + 22))
            thirtysecondLightPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 37.5, y: thirtySecondFrame.minY + 19))
            thirtysecondLightPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.48, y: thirtySecondFrame.minY + 19))
            thirtysecondLightPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.48, y: thirtySecondFrame.minY + 18))
            thirtysecondLightPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.5, y: thirtySecondFrame.minY + 18))
            thirtysecondLightPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.5, y: thirtySecondFrame.minY + 17))
            thirtysecondLightPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 37.5, y: thirtySecondFrame.minY + 17))
            thirtysecondLightPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 37.5, y: thirtySecondFrame.minY + 14))
            thirtysecondLightPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.05, y: thirtySecondFrame.minY + 14))
            thirtysecondLightPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 30.61, y: thirtySecondFrame.minY + 14))
            thirtysecondLightPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 30.61, y: thirtySecondFrame.minY + 14))
            thirtysecondLightPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 29.48, y: thirtySecondFrame.minY + 14))
            thirtysecondLightPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 29.48, y: thirtySecondFrame.minY + 32.48))
            thirtysecondLightPath.addCurve(to: CGPoint(x: thirtySecondFrame.minX + 24.92, y: thirtySecondFrame.minY + 33.14), controlPoint1: CGPoint(x: thirtySecondFrame.minX + 28.27, y: thirtySecondFrame.minY + 32.33), controlPoint2: CGPoint(x: thirtySecondFrame.minX + 26.63, y: thirtySecondFrame.minY + 32.55))
            thirtysecondLightPath.addCurve(to: CGPoint(x: thirtySecondFrame.minX + 20.06, y: thirtySecondFrame.minY + 37.45), controlPoint1: CGPoint(x: thirtySecondFrame.minX + 21.78, y: thirtySecondFrame.minY + 34.22), controlPoint2: CGPoint(x: thirtySecondFrame.minX + 19.61, y: thirtySecondFrame.minY + 36.15))
            thirtysecondLightPath.addCurve(to: CGPoint(x: thirtySecondFrame.minX + 26.55, y: thirtySecondFrame.minY + 37.86), controlPoint1: CGPoint(x: thirtySecondFrame.minX + 20.51, y: thirtySecondFrame.minY + 38.76), controlPoint2: CGPoint(x: thirtySecondFrame.minX + 23.41, y: thirtySecondFrame.minY + 38.94))
            thirtysecondLightPath.addCurve(to: CGPoint(x: thirtySecondFrame.minX + 31.46, y: thirtySecondFrame.minY + 34), controlPoint1: CGPoint(x: thirtySecondFrame.minX + 29.33, y: thirtySecondFrame.minY + 36.9), controlPoint2: CGPoint(x: thirtySecondFrame.minX + 31.36, y: thirtySecondFrame.minY + 35.27))
            thirtysecondLightPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.46, y: thirtySecondFrame.minY + 34))
            thirtysecondLightPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.48, y: thirtySecondFrame.minY + 34))
            thirtysecondLightPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.48, y: thirtySecondFrame.minY + 27))
            thirtysecondLightPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 37.5, y: thirtySecondFrame.minY + 27))
            thirtysecondLightPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 37.5, y: thirtySecondFrame.minY + 24))
            thirtysecondLightPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.5, y: thirtySecondFrame.minY + 24))
            thirtysecondLightPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.5, y: thirtySecondFrame.minY + 24))
            thirtysecondLightPath.close()
            UIGroover.noteGray.setFill()
            thirtysecondLightPath.fill()
        }


        if (thirtysecondActive) {
            //// thirtysecondDark Drawing
            let thirtysecondDarkPath = UIBezierPath()
            thirtysecondDarkPath.move(to: CGPoint(x: thirtySecondFrame.minX + 31.5, y: thirtySecondFrame.minY + 24))
            thirtysecondDarkPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.5, y: thirtySecondFrame.minY + 22))
            thirtysecondDarkPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 37.5, y: thirtySecondFrame.minY + 22))
            thirtysecondDarkPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 37.5, y: thirtySecondFrame.minY + 19))
            thirtysecondDarkPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.48, y: thirtySecondFrame.minY + 19))
            thirtysecondDarkPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.48, y: thirtySecondFrame.minY + 18))
            thirtysecondDarkPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.5, y: thirtySecondFrame.minY + 18))
            thirtysecondDarkPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.5, y: thirtySecondFrame.minY + 17))
            thirtysecondDarkPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 37.5, y: thirtySecondFrame.minY + 17))
            thirtysecondDarkPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 37.5, y: thirtySecondFrame.minY + 14))
            thirtysecondDarkPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.05, y: thirtySecondFrame.minY + 14))
            thirtysecondDarkPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 30.61, y: thirtySecondFrame.minY + 14))
            thirtysecondDarkPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 30.61, y: thirtySecondFrame.minY + 14))
            thirtysecondDarkPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 29.48, y: thirtySecondFrame.minY + 14))
            thirtysecondDarkPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 29.48, y: thirtySecondFrame.minY + 32.48))
            thirtysecondDarkPath.addCurve(to: CGPoint(x: thirtySecondFrame.minX + 24.92, y: thirtySecondFrame.minY + 33.14), controlPoint1: CGPoint(x: thirtySecondFrame.minX + 28.27, y: thirtySecondFrame.minY + 32.33), controlPoint2: CGPoint(x: thirtySecondFrame.minX + 26.63, y: thirtySecondFrame.minY + 32.55))
            thirtysecondDarkPath.addCurve(to: CGPoint(x: thirtySecondFrame.minX + 20.06, y: thirtySecondFrame.minY + 37.45), controlPoint1: CGPoint(x: thirtySecondFrame.minX + 21.78, y: thirtySecondFrame.minY + 34.22), controlPoint2: CGPoint(x: thirtySecondFrame.minX + 19.61, y: thirtySecondFrame.minY + 36.15))
            thirtysecondDarkPath.addCurve(to: CGPoint(x: thirtySecondFrame.minX + 26.55, y: thirtySecondFrame.minY + 37.86), controlPoint1: CGPoint(x: thirtySecondFrame.minX + 20.51, y: thirtySecondFrame.minY + 38.76), controlPoint2: CGPoint(x: thirtySecondFrame.minX + 23.41, y: thirtySecondFrame.minY + 38.94))
            thirtysecondDarkPath.addCurve(to: CGPoint(x: thirtySecondFrame.minX + 31.46, y: thirtySecondFrame.minY + 34), controlPoint1: CGPoint(x: thirtySecondFrame.minX + 29.33, y: thirtySecondFrame.minY + 36.9), controlPoint2: CGPoint(x: thirtySecondFrame.minX + 31.36, y: thirtySecondFrame.minY + 35.27))
            thirtysecondDarkPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.46, y: thirtySecondFrame.minY + 34))
            thirtysecondDarkPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.48, y: thirtySecondFrame.minY + 34))
            thirtysecondDarkPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.48, y: thirtySecondFrame.minY + 27))
            thirtysecondDarkPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 37.5, y: thirtySecondFrame.minY + 27))
            thirtysecondDarkPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 37.5, y: thirtySecondFrame.minY + 24))
            thirtysecondDarkPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.5, y: thirtySecondFrame.minY + 24))
            thirtysecondDarkPath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.5, y: thirtySecondFrame.minY + 24))
            thirtysecondDarkPath.close()
            UIGroover.noteDark.setFill()
            thirtysecondDarkPath.fill()
        }


        if (thirtysecondSelected) {
            //// thirtysecondBlue Drawing
            let thirtysecondBluePath = UIBezierPath()
            thirtysecondBluePath.move(to: CGPoint(x: thirtySecondFrame.minX + 31.5, y: thirtySecondFrame.minY + 24))
            thirtysecondBluePath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.5, y: thirtySecondFrame.minY + 22))
            thirtysecondBluePath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 37.5, y: thirtySecondFrame.minY + 22))
            thirtysecondBluePath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 37.5, y: thirtySecondFrame.minY + 19))
            thirtysecondBluePath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.48, y: thirtySecondFrame.minY + 19))
            thirtysecondBluePath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.48, y: thirtySecondFrame.minY + 18))
            thirtysecondBluePath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.5, y: thirtySecondFrame.minY + 18))
            thirtysecondBluePath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.5, y: thirtySecondFrame.minY + 17))
            thirtysecondBluePath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 37.5, y: thirtySecondFrame.minY + 17))
            thirtysecondBluePath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 37.5, y: thirtySecondFrame.minY + 14))
            thirtysecondBluePath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.05, y: thirtySecondFrame.minY + 14))
            thirtysecondBluePath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 30.61, y: thirtySecondFrame.minY + 14))
            thirtysecondBluePath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 30.61, y: thirtySecondFrame.minY + 14))
            thirtysecondBluePath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 29.48, y: thirtySecondFrame.minY + 14))
            thirtysecondBluePath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 29.48, y: thirtySecondFrame.minY + 32.48))
            thirtysecondBluePath.addCurve(to: CGPoint(x: thirtySecondFrame.minX + 24.92, y: thirtySecondFrame.minY + 33.14), controlPoint1: CGPoint(x: thirtySecondFrame.minX + 28.27, y: thirtySecondFrame.minY + 32.33), controlPoint2: CGPoint(x: thirtySecondFrame.minX + 26.63, y: thirtySecondFrame.minY + 32.55))
            thirtysecondBluePath.addCurve(to: CGPoint(x: thirtySecondFrame.minX + 20.06, y: thirtySecondFrame.minY + 37.45), controlPoint1: CGPoint(x: thirtySecondFrame.minX + 21.78, y: thirtySecondFrame.minY + 34.22), controlPoint2: CGPoint(x: thirtySecondFrame.minX + 19.61, y: thirtySecondFrame.minY + 36.15))
            thirtysecondBluePath.addCurve(to: CGPoint(x: thirtySecondFrame.minX + 26.55, y: thirtySecondFrame.minY + 37.86), controlPoint1: CGPoint(x: thirtySecondFrame.minX + 20.51, y: thirtySecondFrame.minY + 38.76), controlPoint2: CGPoint(x: thirtySecondFrame.minX + 23.41, y: thirtySecondFrame.minY + 38.94))
            thirtysecondBluePath.addCurve(to: CGPoint(x: thirtySecondFrame.minX + 31.46, y: thirtySecondFrame.minY + 34), controlPoint1: CGPoint(x: thirtySecondFrame.minX + 29.33, y: thirtySecondFrame.minY + 36.9), controlPoint2: CGPoint(x: thirtySecondFrame.minX + 31.36, y: thirtySecondFrame.minY + 35.27))
            thirtysecondBluePath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.46, y: thirtySecondFrame.minY + 34))
            thirtysecondBluePath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.48, y: thirtySecondFrame.minY + 34))
            thirtysecondBluePath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.48, y: thirtySecondFrame.minY + 27))
            thirtysecondBluePath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 37.5, y: thirtySecondFrame.minY + 27))
            thirtysecondBluePath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 37.5, y: thirtySecondFrame.minY + 24))
            thirtysecondBluePath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.5, y: thirtySecondFrame.minY + 24))
            thirtysecondBluePath.addLine(to: CGPoint(x: thirtySecondFrame.minX + 31.5, y: thirtySecondFrame.minY + 24))
            thirtysecondBluePath.close()
            UIGroover.lightBlue.setFill()
            thirtysecondBluePath.fill()
        }
        
        context.restoreGState()

    }

    public dynamic class func drawTripletCanvas(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 54, height: 54), resizing: ResizingBehavior = .aspectFit, tripletSelected: Bool = false, tripletActive: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 54, height: 54), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 54, y: resizedFrame.height / 54)



        //// Variable Declarations
        let tripletDeselected = !tripletSelected

        //// Frames
        let tripletFrame = CGRect(x: 0, y: 0, width: 54, height: 54)


        //// tripletButton
        if (tripletActive) {
            //// buttonBlue 2 Drawing
            let buttonBlue2Path = UIBezierPath(roundedRect: CGRect(x: tripletFrame.minX, y: tripletFrame.minY, width: 54, height: 54), cornerRadius: 6)
            UIGroover.lightBlue.setFill()
            buttonBlue2Path.fill()
        }


        if (tripletSelected) {
            //// buttonOutline 2 Drawing
            let buttonOutline2Path = UIBezierPath(roundedRect: CGRect(x: tripletFrame.minX, y: tripletFrame.minY, width: 54, height: 54), cornerRadius: 6)
            UIGroover.lightBlue.setStroke()
            buttonOutline2Path.lineWidth = 2
            buttonOutline2Path.stroke()
        }


        if (tripletDeselected) {
            //// buttonBlack 2 Drawing
            let buttonBlack2Path = UIBezierPath(roundedRect: CGRect(x: tripletFrame.minX + 5, y: tripletFrame.minY + 5, width: 44, height: 44), cornerRadius: 6)
            UIGroover.black.setFill()
            buttonBlack2Path.fill()


            //// tripletLight Drawing
            let tripletLightPath = UIBezierPath()
            tripletLightPath.move(to: CGPoint(x: tripletFrame.minX + 25.53, y: tripletFrame.minY + 34.5))
            tripletLightPath.addLine(to: CGPoint(x: tripletFrame.minX + 25.53, y: tripletFrame.minY + 21.67))
            tripletLightPath.addLine(to: CGPoint(x: tripletFrame.minX + 21, y: tripletFrame.minY + 21.67))
            tripletLightPath.addLine(to: CGPoint(x: tripletFrame.minX + 21, y: tripletFrame.minY + 19))
            tripletLightPath.addLine(to: CGPoint(x: tripletFrame.minX + 33.32, y: tripletFrame.minY + 19))
            tripletLightPath.addLine(to: CGPoint(x: tripletFrame.minX + 33.32, y: tripletFrame.minY + 21.67))
            tripletLightPath.addLine(to: CGPoint(x: tripletFrame.minX + 28.78, y: tripletFrame.minY + 21.67))
            tripletLightPath.addLine(to: CGPoint(x: tripletFrame.minX + 28.78, y: tripletFrame.minY + 34.5))
            tripletLightPath.addLine(to: CGPoint(x: tripletFrame.minX + 25.53, y: tripletFrame.minY + 34.5))
            tripletLightPath.close()
            UIGroover.noteGray.setFill()
            tripletLightPath.fill()
        }


        if (tripletActive) {
            //// tripletDark Drawing
            let tripletDarkPath = UIBezierPath()
            tripletDarkPath.move(to: CGPoint(x: tripletFrame.minX + 25.53, y: tripletFrame.minY + 34.5))
            tripletDarkPath.addLine(to: CGPoint(x: tripletFrame.minX + 25.53, y: tripletFrame.minY + 21.67))
            tripletDarkPath.addLine(to: CGPoint(x: tripletFrame.minX + 21, y: tripletFrame.minY + 21.67))
            tripletDarkPath.addLine(to: CGPoint(x: tripletFrame.minX + 21, y: tripletFrame.minY + 19))
            tripletDarkPath.addLine(to: CGPoint(x: tripletFrame.minX + 33.32, y: tripletFrame.minY + 19))
            tripletDarkPath.addLine(to: CGPoint(x: tripletFrame.minX + 33.32, y: tripletFrame.minY + 21.67))
            tripletDarkPath.addLine(to: CGPoint(x: tripletFrame.minX + 28.78, y: tripletFrame.minY + 21.67))
            tripletDarkPath.addLine(to: CGPoint(x: tripletFrame.minX + 28.78, y: tripletFrame.minY + 34.5))
            tripletDarkPath.addLine(to: CGPoint(x: tripletFrame.minX + 25.53, y: tripletFrame.minY + 34.5))
            tripletDarkPath.close()
            UIGroover.noteDark.setFill()
            tripletDarkPath.fill()
        }


        if (tripletSelected) {
            //// tripletBlue Drawing
            let tripletBluePath = UIBezierPath()
            tripletBluePath.move(to: CGPoint(x: tripletFrame.minX + 25.53, y: tripletFrame.minY + 34.5))
            tripletBluePath.addLine(to: CGPoint(x: tripletFrame.minX + 25.53, y: tripletFrame.minY + 21.67))
            tripletBluePath.addLine(to: CGPoint(x: tripletFrame.minX + 21, y: tripletFrame.minY + 21.67))
            tripletBluePath.addLine(to: CGPoint(x: tripletFrame.minX + 21, y: tripletFrame.minY + 19))
            tripletBluePath.addLine(to: CGPoint(x: tripletFrame.minX + 33.32, y: tripletFrame.minY + 19))
            tripletBluePath.addLine(to: CGPoint(x: tripletFrame.minX + 33.32, y: tripletFrame.minY + 21.67))
            tripletBluePath.addLine(to: CGPoint(x: tripletFrame.minX + 28.78, y: tripletFrame.minY + 21.67))
            tripletBluePath.addLine(to: CGPoint(x: tripletFrame.minX + 28.78, y: tripletFrame.minY + 34.5))
            tripletBluePath.addLine(to: CGPoint(x: tripletFrame.minX + 25.53, y: tripletFrame.minY + 34.5))
            tripletBluePath.close()
            UIGroover.lightBlue.setFill()
            tripletBluePath.fill()
        }
        
        context.restoreGState()

    }

    public dynamic class func drawPlayCanvas(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 87, height: 56), resizing: ResizingBehavior = .aspectFit, playSelected: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 87, height: 56), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 87, y: resizedFrame.height / 56)



        //// Variable Declarations
        let playColor = playSelected ? UIGroover.transportGreen : UIGroover.transportDark

        //// Frames
        let playFrame = CGRect(x: 0, y: 0, width: 87, height: 56)


        //// playButtonGroup
        //// playButton Drawing
        let playButtonPath = UIBezierPath()
        playButtonPath.move(to: CGPoint(x: playFrame.minX + 33, y: playFrame.minY + 40))
        playButtonPath.addLine(to: CGPoint(x: playFrame.minX + 33, y: playFrame.minY + 18))
        playButtonPath.addLine(to: CGPoint(x: playFrame.minX + 55, y: playFrame.minY + 29))
        playButtonPath.addLine(to: CGPoint(x: playFrame.minX + 33, y: playFrame.minY + 40))
        playButtonPath.close()
        playColor.setFill()
        playButtonPath.fill()
        
        context.restoreGState()

    }

    public dynamic class func drawRecordCanvas(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 87, height: 56), resizing: ResizingBehavior = .aspectFit, recordSelected: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 87, height: 56), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 87, y: resizedFrame.height / 56)



        //// Variable Declarations
        let recordColor = recordSelected ? UIGroover.transportRed : UIGroover.transportDark

        //// Frames
        let recordFrame = CGRect(x: 0, y: 0, width: 87, height: 56)


        //// recordButtonGroup
        //// recordButton Drawing
        let recordButtonPath = UIBezierPath(ovalIn: CGRect(x: recordFrame.minX + 33, y: recordFrame.minY + 17, width: 22, height: 22))
        recordColor.setFill()
        recordButtonPath.fill()
        
        context.restoreGState()

    }




    @objc public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}
